<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans,en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="neverchanje">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="neverchanje">
<meta property="og:locale" content="zh-Hans,en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="neverchanje">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>neverchanje</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans,en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">neverchanje</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/11/leveldb_3_version/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="neverchanje">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="neverchanje">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/11/leveldb_3_version/" itemprop="url">leveldb 源码解说(3)：Version 和 VersionSet</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-11T00:00:00+08:00">
                2016-12-11
              </time>
            

            

            
          </span>

          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在阅读这篇文章之前希望读者先阅读 <a href="https://github.com/facebook/rocksdb/wiki/MANIFEST" target="_blank" rel="noopener">rocksdb wiki 关于 Version 和 VersionEdit 的介绍</a>，其实很多东西在这里已经介绍的很清楚了。</p>
<hr>
<p>Version 和 VersionSet 是 leveldb 最乱的地方之一。看的时候要保持思考保持清醒（这是个软件工程问题）。先看 <code>Version::Get</code>。</p>
<h2 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h2><p>Version 管理磁盘上所有文件的元信息（简单说就是所有 SSTables 的 metadata），比方说哪一层有哪些文件，并且为了提升效率，我们要在内存中维护这些文件的 FileMetaData，这样我们就不用每次都去读文件才能得知每个文件的 key range。这些元数据交给 Version 来维护。每次删掉一个文件，都会导致 Version 被改变，产生出一个新的 Version。能够表现当前 DB 状态的 Version，被称作 current version 。所有 Version 都被 VersionSet 用一个循环双向链表维护起来。</p>
<p>其实这就有点类似 MVCC 了。MVCC 是数据库解决并发问题的时候一个很常见的概念。利用版本号的一种实现是，并发的时候数据行有多个版本用链表串在一起，写的时候拷贝一份快照出来写，加上版本号之后就变成新版本插到链表里，每个读事务只能读比自己版本号更小的，所以本质上读的时候可以进行写操作。（参考 张帅同学在知乎的回答）</p>
<p>leveldb 也需要类似的思想。我们后面会讲到 leveldb compaction 的机制，简单说就是 leveldb 时不时的会对一些文件进行清理（可以看成是做压缩），然后把清理干净后的数据放到新的文件集合里，这样就导致同一份数据有两批文件，旧的那一批按道理应该删掉，但是如果现在有读事务在旧的那批文件上，则暂时还不能删。所以我们利用引用计数的机制，只要一个 Version 还存活着，那么它管理的所有文件都不会被删，而一旦 Version 生命周期结束，则它管理的所有文件引用计数全部减一（参考 Version::~Version），当没有一个 Version 引用这个文件，那这个文件就可以直接删了。在引用计数这一方面，还要考虑多个用户访问这个 Version 的情况。也就是说，除了文件要引用计数，Version 自己也要引用计数。</p>
<p>这里有一点要注意，memtable 不归 current version 管理。只有磁盘上的数据才归 Version 管理。不过当然，memtable 本身也有引用计数。所以在 DBImpl::Get 的时候，current，memtable，im-memtable 的引用计数都会加 1，在结束的时候减一。这样就保证读的时候 memtable 不会突然被删。</p>
<h2 id="Version-Get"><a href="#Version-Get" class="headerlink" title="Version::Get"></a>Version::Get</h2><p><code>Version::Get()</code> 查询一个 key 对应的 value，这是 leveldb 查询 key 的核心过程（划重点）。了解这步操作之前，我们首先需要知道 leveldb 的大致执行流程：首先数据会先写到 memtable，当 memtable 超过一定大小限制，数据会被持久化到 L0，为了避免在写到 L0 的同时 memtable 不可写的情况，memtable 会专门拷贝一份到 immutable memtable，顾名思义是只读的，相当于一份快照，然后利用 immutable memtable 把这份快照写到 L0。</p>
<p>执行到 <code>Version::Get</code> 这步之前（参照 <code>DBImpl::Get</code>），我们已经得知 memtable 和 immutable memtable 中没有对应 key，所以我们从 SSTable 中查（这里说的不够准确，后续再提）。查询过程显然是从上到下（level 0 -&gt; level 1 -&gt; … ）逐层遍历，这是因为 LSM tree 已经定义越新的越处于上层，所以我们一定是选择版本最新的，即含有 key 的最上层。</p>
<p>对于每一层的查询，首要的一个逻辑是定位 key 在哪一个文件，然后定位 key 在这个文件的位置，最终获得 key 的 value。</p>
<ol>
<li>在 level 0 定位 key：所以我们可以按照 file number 从大到小排序（越大的越新）然后依次遍历，每个文件都会有一个 key range（参照 FileMetaData），如果我们的 key 在该 range 里，则我们尝试在该文件里二分查找这个 key，如果 key 不在 range 里则 continue。通过 key range 过滤只是一种比较简单的优化，在 L0 的查询终究是比较慢的，所以 L0 的文件数必须要足够少（最坏情况下每个文件都要读一遍）。</li>
<li>在 level n (n&gt;0) 定位 key：在 level n &gt; 0 上，SSTables 之间的 key ranges 不会相交，我们可以利用这点进行二分找到指定文件 （参照 version_set.c:FindFile），然后在文件里进行二分找到 key（参照 TableCache::Get）。</li>
<li>如果找到的 key 对应的是 Delete record，那说明这个 key 已经被删了，返回 Status::NotFound。</li>
</ol>
<p><code>Version::Get</code> 最后会返回 key 对应的 value，key 所在的文件（GetStats）。</p>
<h2 id="VersionSet-LogAndApply"><a href="#VersionSet-LogAndApply" class="headerlink" title="VersionSet::LogAndApply"></a>VersionSet::LogAndApply</h2><p>顾名思义这个函数是用来把 VersionEdit 加到 Version 里成为新的 Version。同时这个过程也会持久化到 Manifest 上。由于涉及到磁盘 IO，不可能在每次 version 改变的时候都执行一次 LogAndApply，通常是批量做。因此，VersionEdit 中包含了一系列对 Version 的修改，包括添加了某个文件，删除了某个文件。把 VersionEdit 加到 Version 里的过程本质和 git commit 是一样的，都是旧版本经过一系列修改之后产生新版本，使用 VersionSet::Builder 执行这段过程，算法很简单，实现看起来却很复杂。</p>
<p>写 MANIFEST 的过程我们知道就是一个写日志的过程，每条 record 意味着有一组的元数据被改变， 每组改变用 VersionEdit 构造，然后 <code>VersionEdit::EncodeTo</code> 写到 record 字符串，最后用 <code>log::Writer::AddRecord</code> 写到日志里。VersionEdit 的内部构造会保证 record 的 compactness（record 里的元数据是 key value 表示，key 是元数据类型，使用 enum 标记，用 varint 存储，不同类型的元数据 value 存储方式不一样，使用 varint 和 varstring 结合存储）。</p>
<p>这里可以总结一下，有下面几个操作会执行 LogAndApply：</p>
<ol>
<li>memtable 刷到 L0 的时候（<code>DBImpl::CompactMemtable</code>），VersionEdit 会在这里记录新的 wal 编号，将 L0 的 FileMetaData 维护起来。</li>
<li>进行 compaction 的时候。VersionEdit 会记录 compaction 导致的文件增加和删除操作。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/16/leveldb_2_log/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="neverchanje">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="neverchanje">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/16/leveldb_2_log/" itemprop="url">leveldb 源码解说(2)：Log</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-16T00:00:00+08:00">
                2016-11-16
              </time>
            

            

            
          </span>

          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面有说到 MANIFEST 用的是日志来记录，这种元数据日志肯定要做 Compaction（leveldb 的 log 文件并不是通过删除冗余日志记录来做 log 的 compaction，而是直接删除过期且无用的 log 文件，参考 <code>DBImpl::DeleteObsoleteFiles</code>），同时也要考虑具体 format（<a href="https://raw.githubusercontent.com/google/leveldb/master/doc/log_format.txt" target="_blank" rel="noopener">官方文档</a>）。</p>
<p>一般为了能快速定位数据（优化读），设计上会把日志文件切分成固定大小的 blocks，leveldb 的日志会被分成 32kb 的 blocks。照道理一个 block 可以作为一个文件， 不过这样会让文件系统管理过多的 metadata (inodes)。所以可以把多个 blocks 放在一个文件里。[?] 暂时不知道一个文件最多能放多少 blocks。</p>
<p>一个 <code>log::Writer</code> 负责对某一个日志执行写操作。日志的切分要考虑 boundary 问题，即考虑一条 record 可能塞不进一个 block 的剩余空间里，这样就需要把这种 record 分成 FIRST, MIDDLE, LAST 三个连续的部分（我们后面会直接称作 fragment）然后塞到多个 blocks 里（其实我觉得多数场景下应该不会有 MIDDLE，因为一条日志一般不会超过 32kb [?]），把可以被塞进一个 block 里的标记为 FULL。</p>
<p>官方文档给出了 block 的 format，作为磁盘文件格式已经比较 compact 了，后续优化空间不大的样子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">block := record* trailer?</span><br><span class="line">record :=                    // 其实这里不太严谨，准确说这应该是 fragment，不是 record</span><br><span class="line">     checksum: uint32        // crc32c of type and data[] ; little-endian</span><br><span class="line">     length: uint16          // little-endian</span><br><span class="line">     type: uint8             // One of FULL, FIRST, MIDDLE, LAST</span><br><span class="line">     data: uint8[length]</span><br></pre></td></tr></table></figure>
<p>block 的实现是比较简单的事情（说实话一般给出 format 设计之后，实现和测试都是时间问题）。这里有必要考虑 checksum 计算的问题，即 crc 计算哪部分的校验和。通常来讲是 length + type + data，这一定是对的，不过 crc 算法本身就包括了字符串长度的检验，我们可以省掉 length 这一项。所以只需要计算 type + data（crc 保证一个校验正确的长度一定是 length+1，这就保证了 length 的正确性，即 type + data 正确，length 一定正确，反之亦然）。leveldb 这里还在 crc 计算中做了小优化，即提前计算好每个 type 的 crc（对应的是 log::Writer::type_crc_），这样就不用每次都重新算一遍。</p>
<p><code>log::Reader</code> 负责对某一个日志进行读操作。读日志是一次性读一个 block 的量到内存里。<code>log::Reader</code> 的实现有些复杂，因为要考虑到错误处理（主要是 Data Corruption，比如磁盘读到一半磁盘挂了，读的内容小于 blocksize， 但要与 eof 区别对待）。leveldb 设计了 <code>log::Reader::Reporter</code> 来让用户自定义错误处理，比方说统计丢失了多少字节。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface for reporting errors.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reporter</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~Reporter();</span><br><span class="line">  <span class="comment">// Some corruption was detected.  "size" is the approximate number</span></span><br><span class="line">  <span class="comment">// of bytes dropped due to the corruption.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Corruption</span><span class="params">(<span class="keyword">size_t</span> bytes, <span class="keyword">const</span> Status&amp; status)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>log::Reader</code> 有个参数是 initial_offset，表示从中断处开始读日志，它会带来些比较麻烦的边界情况：</p>
<p>考虑到我们是一个 block 一个 block 依次读的，然而 <code>log::Reader</code> 的 <code>initial_offset_</code> 不一定在 block 的起始处，它很可能在某 block 的中间，为了方便说明，把这个 block 记作 x。我们还是按照规则把整个 x 读到内存。x 的起始处到 initial_offset 这段区间上的 records 我们都忽略掉。<br>读到这个 fragment 之后我们要判断它是不是 MIDDLE 或者 LAST 的，如果是的话，我们就把它忽略，这里需要把因为错误而忽略的字节数报给 reporter。<br>还有一些边界情况：</p>
<p>我们定义了 <code>record := FULL / FIRST + MIDDLE* + LAST</code>，所以如果出现</p>
<ul>
<li>FIRST 后面跟 FULL，报错给 reporter</li>
<li>FIRST 或者 MIDDLE 后面跟 FIRST，报错给 reporter</li>
<li>LAST 后面跟 MIDDLE，报错</li>
<li>type 不是 FULL / FIRST / MIDDLE / LAST 的任何一个，报错</li>
<li>crc 校验失败，字符串长度和实际不符，报错</li>
</ul>
<p>在 <code>log::Reader</code> 的实现里面会看到 resyncing 这个词。在 RAID 1(mirrored) 磁盘阵列里，resync 指的是数据写的时候中途宕机，导致几个磁盘数据不一致，恢复的时候在后台线程重新进行同步，保证几个副本一致性的过程（参考）。在 <code>log::Reader</code> 里，<code>resyncing_</code> 表示我们是否是从一个中断处（&gt;0 的 initial_offset ）开始读日志的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/12/leveldb_1_preview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="neverchanje">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="neverchanje">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/12/leveldb_1_preview/" itemprop="url">leveldb 源码解说(1)：Preview</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-12T00:00:00+08:00">
                2016-11-12
              </time>
            

            

            
          </span>

          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>这系列博文被我叫做源码解说，但我并不想太细地描述 leveldb 的代码逻辑，我更希望能够对 leveldb 的各种实现策略进行解读。leveldb 经过这么长时间的发展，其实内部的一些策略已经足以成为教科书式的范例。我提前建议，读者最好对操作系统和数据库有自己的理解再来读。因为我自己也想用 C++11 重写一套兼容 leveldb 接口（其实不太难）的存储引擎。另一方面，我也会从一个实现者的角度来解说，而不会简单概括原理。如有错误欢迎指出。</p>
<p>除了我的文章之外，还有一些文章我认为比较好的资料可以阅读：</p>
<ul>
<li><a href="http://blog.csdn.net/sparkliang/article/category/1342001" target="_blank" rel="noopener">sparkliang 的leveldb 源码分析</a></li>
<li><a href="https://github.com/facebook/rocksdb/wiki" target="_blank" rel="noopener">rocksdb wiki</a></li>
</ul>
<h2 id="leveldb-介绍"><a href="#leveldb-介绍" class="headerlink" title="leveldb 介绍"></a>leveldb 介绍</h2><p>在这个专题的开始，我们介绍一下 leveldb 的大致原理，这样后面的各个小节可以相互隔离。</p>
<p><img src="http://og0xhkmh3.bkt.clouddn.com/leveldb_architecture.jpg" alt="leveldb architecture"></p>
<p>来自 An Efficient Design and Implementation of LSM-Tree based Key-Value Store on Open-Channel SSD。<br>对 leveldb 的介绍有很多了，这篇论文的 2.1节 简单介绍了一下 leveldb。</p>
<h3 id="LSM"><a href="#LSM" class="headerlink" title="LSM"></a>LSM</h3><p>LSM 的设计是为了减少 random writes，同时保证 acceptable read performance。这里我们给几个 LSM 的结论：</p>
<ul>
<li><p>L0 的数据是从 memtable 刷下来的（实现在 <code>DBImpl::WriteLevel0Table</code>），由于 append-only 策略，L0 的 SSTable 内部不会 overlap（所以 SSTable 全称是 Sorted String Table），因为从 memtable 刷下来的时候会做一次 compaction，但是 SSTable 之间会 overlap。</p>
</li>
<li><p>L0 往下，每一层的 SSTable 都经过了 compaction 才刷下来的（我们应该把这叫 GC）。所以除了 L0 以外，同层之间不会 overlap，而层与层之间会 overlap。</p>
</li>
</ul>
<h3 id="Glossary"><a href="#Glossary" class="headerlink" title="Glossary"></a>Glossary</h3><ul>
<li><p>overlap 的含义这里做个简单解释：一个 key 的生命周期里，它可能会被多次 update，也可能会最终被 delete，每次 update 操作都相当于 append 一个新 record，delete 操作也是通过 append 一个 tombstone record ，把前面的操作覆盖掉，这种新版本覆盖旧版本的情况就叫 overlap，这是 append-only 的思想（相信这些对读者应该是废话）。但在 leveldb 上 overlap 的含义又做了扩展：SSTable 由于按 keys 排序，所以一个 SSTable 文件有一个 key range，如果两个 SSTable 的 key range 有交集，也叫作 overlap。</p>
</li>
<li><p>compaction 这里也做一个解释：我们把旧版本操作去掉，只留下最新的，这就是 compaction。</p>
</li>
</ul>
<h2 id="从-db-bench-开始"><a href="#从-db-bench-开始" class="headerlink" title="从 db_bench 开始"></a>从 db_bench 开始</h2><p>由于工作原因，我需要去阅读一些项目源码，知乎上有些朋友认为阅读源码先去阅读 main 函数，对大概流程有个了解之后再去针对模块阅读。这本质是对的，但是我们仍然可以有一些取巧的方法，比如读 benchmark 的代码，比如读单元测试的代码。这些经常被忽略的东西其实是阅读源码很好的切入点，能给读者所见即所得的过程。</p>
<p>我们从 main 函数开始看，这里用的是非常原始的命令行手动解析（连 <code>--help</code> 都没有）。其实 gflags 做 command line flags 还是蛮好用的，不考虑依赖的话应该用 gflags。</p>
<p>如果不指定的话（<code>--db</code>），leveldb 的日志文件数据文件都会放在 <code>/tmp/leveldb-%d/dbbench</code> 下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  dbbench ls -lh | awk &apos;&#123;print($5,$9)&#125;&apos;</span><br><span class="line">3.3M 000071.log</span><br><span class="line">2.1M 000080.ldb</span><br><span class="line">2.1M 000081.ldb</span><br><span class="line">...</span><br><span class="line">2.1M 000112.ldb</span><br><span class="line">2.1M 000113.ldb</span><br><span class="line">16 CURRENT</span><br><span class="line">0 LOCK</span><br><span class="line">17K LOG</span><br><span class="line">5.8K MANIFEST-000002</span><br></pre></td></tr></table></figure>
<p>可以看到非常工整的 2.1M ldb，空的 LOCK 文件，CURRENT 的内容是 ”MANIFEST-000002“，可以推断 CURRENT 指向最新的 MANIFEST。具体的文件名定义可以在 filename.h/cc 里找到。我们可以在 google 官方文档 里看到这些文件的解释。</p>
<h3 id="leveldb-里的各种文件"><a href="#leveldb-里的各种文件" class="headerlink" title="leveldb 里的各种文件"></a>leveldb 里的各种文件</h3><ul>
<li><p>MANIFEST 的文件名对应的是 DescriptorFileName，用来持久化一些 leveldb 的 metadata。每次 leveldb 的元数据改变，不会重写 MANIFEST（因为元数据很多，每次都因为一两个元数据的改变就重写的话效率太低），而是使用日志来记录 DB 元数据的改变（append-only）。后续再细讲 MANIFEST。</p>
</li>
<li><p>CURRENT 指向最新的 MANIFEST</p>
</li>
<li><p>LOCK 即用来做文件锁，后面在 DestroyDB 中会介绍</p>
</li>
<li><p>.ldb 文件是存 SSTable 的数据文件，以前叫 .sst，后来因为一些原因所以换了后缀。</p>
</li>
</ul>
<p>benchmark 结果（这块是 SSD 和 SATA 的混合盘）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fillseq      :       2.674 micros/op;   41.4 MB/s</span><br><span class="line">fillsync     :    1391.578 micros/op;    0.1 MB/s (1000 ops)</span><br><span class="line">fillrandom   :       4.380 micros/op;   25.3 MB/s</span><br><span class="line">overwrite    :       6.616 micros/op;   16.7 MB/s</span><br><span class="line">readrandom   :       7.241 micros/op; (1000000 of 1000000 found)</span><br><span class="line">readrandom   :       6.575 micros/op; (1000000 of 1000000 found)</span><br><span class="line">readseq      :       0.265 micros/op;  417.4 MB/s</span><br><span class="line">readreverse  :       0.434 micros/op;  254.9 MB/s</span><br><span class="line">compact      :  819660.000 micros/op;</span><br><span class="line">readrandom   :       4.581 micros/op; (1000000 of 1000000 found)</span><br><span class="line">readseq      :       0.243 micros/op;  454.5 MB/s</span><br><span class="line">readreverse  :       0.381 micros/op;  290.6 MB/s</span><br><span class="line">fill100K     :    1334.272 micros/op;   71.5 MB/s (1000 ops)</span><br><span class="line">crc32c       :       4.285 micros/op;  911.5 MB/s (4K per op)</span><br><span class="line">snappycomp   :       5.795 micros/op;  674.1 MB/s (output: 55.1%)</span><br><span class="line">snappyuncomp :       0.841 micros/op; 4643.7 MB/s</span><br><span class="line">acquireload  :       0.416 micros/op; (each op is 1000 loads)</span><br></pre></td></tr></table></figure>
<p>这里的几个测试写的 benchmark 有 fill 和 overwrite。写测试结束之后默认都需要清空数据库，类似于 DROP TABLE，对应 <code>db_impl.cc/DestroyDB</code>。[?] 调用 DestroyDB 之后再把 DB delete 掉，在下次使用时重新 Open。</p>
<p>DestroyDB 的参数 dbname（包括 FLAGS_db）即 <code>/tmp/leveldbtest-0/dbbench</code>。删除数据库即将该目录删除。删除该目录还需要考虑并发问题。</p>
<blockquote>
<p><strong>文件锁</strong><br>DestroyDB 是通过文件锁来解决并发时候的一致性问题的，相当于每次 DestroyDB 都是一次事务。文件锁有两种概念，一种是多进程场景下的，利用 fcntl 和 flock 来实现，一种是多线程场景下的，我们没有必要使用系统调用，可以直接在用户态内存中维护一个锁表（set实现，申请锁就往 set 里插入文件名，释放锁就 erase 该文件名，如果 set 中已有该文件则操作失败），这样利用简单的 mutex 来实现即可。<br>锁表其实是一种 tradeoff。加锁写时开销大，争抢锁时开销小，优化多线程 contention。加锁过程在锁表加锁，再加文件锁。释放锁就倒个顺序。</p>
</blockquote>
<p>benchmark 的执行方法 <code>Benchmark::RunBenchmark</code>：每个 benchmark 都开多个线程（–thread）执行来模拟并发。最后再将多个线程的结果 merge 起来，就是总的结果。当然并发这部分未来还是用 count_down_latch 来实现，leveldb 这种写法比较丑（用一个 SharedState，本质还是 count_down_latch）。</p>
<ul>
<li><code>Benchmark::WriteSeq / Benchmark::WriteRandom -&gt; Benchmark::DoWrite</code>。</li>
</ul>
<p>顺序写保证有多少个写操作就有多少个 entries， 随机写则不一定，有些写操作可能是 update，leveldb 的更新和插入用的都是 <code>DB::Put</code>。</p>
<blockquote>
<p><strong>用 DB::Write 进行写</strong><br>来看写过程：通过 WriteBatch，然后再用 <code>DB::Write</code> 写到数据库中，WriteBatch 相当于一个辅助类，给使用者一个批处理的接口，对用户而言，一个 entry 就是一对 Key + Value，然而对于 leveldb 而言，一个 entry 是 InternalKey + Value。WriteBatch 就是用来将用户的 entry 转化成 leveldb 的 entry。然后组成 batch 一起写到 DB 中。比较形象的形容是，对应到 MySQL 中，我们可以认为是一组 INSERT 语句，然后用一个 Transaction 写到 DB，WriteBatch 就是用来生成这一组 INSERT。</p>
</blockquote>
<ul>
<li><code>Benchmark::ReadSequential</code> 和 <code>Benchmark::ReadReverse</code> 用的是 <code>DB::NewIterator</code> 创建迭代器来遍历。</li>
</ul>
<blockquote>
<p><strong>leveldb 的 Iterator</strong><br>leveldb 的 Iterator 设计优势在于头文件确实干净，缺点在于不那么 modern-c++-style，用完还要 delete。未来我们可以用 <code>silly::IteratorFacade</code>（更干净的 <code>boost::iterator_facade</code>） 来做。</p>
</blockquote>
<ul>
<li><p><code>Benchmark::ReadRandom</code> 就是随机 Key，用 <code>DB::Get</code> 查。<code>Benchmark::ReadHot</code> 比较有意思，随机 Key 的范围更小，应该可以用来测试 cache 性能。</p>
</li>
<li><p>这里专门有一个 <code>Benchmark::SeekRandom</code> 的测试，用的是 <code>Iterator::Seek</code>。现在暂时还不清楚 <code>DB::Get</code> 和 <code>Iterator::Seek</code> 有什么区别。</p>
</li>
<li><p><code>Benchmark::Compact</code> 会对整个 DB 进行一次 Compact（相信读者已经懂 leveldb 大致原理）。这是 leveldb 的一块很硬的蛋糕，调用 <code>DBImpl::CompactRange</code>。</p>
</li>
<li><p><code>Benchmark::SnappyCompress</code> 只是单纯测试 snappy 算法压缩 1G 数据的效率，<code>Benchmark::SnappyUncompress</code> 也只是测试解压效率。一开始还以为是测试加了 snappy 的读写效率。</p>
</li>
</ul>
<p>其实还有其他几个 benchmark，我们可以在 FLAGS_benchmark 加，但是我想等我们深入了解了 leveldb 再回来实际测一番。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/03/11/three_methods_to_implement_interface_in_cpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="neverchanje">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="neverchanje">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/11/three_methods_to_implement_interface_in_cpp/" itemprop="url">c++ 的三种实现接口的方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-11T00:00:00+08:00">
                2016-03-11
              </time>
            

            

            
          </span>

          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="传统-interface"><a href="#传统-interface" class="headerlink" title="传统 interface"></a>传统 interface</h2><p>想要实现 interface，在绝大多数 OOP 语言中，会被认为只有一种。如 java 和 C# 的 interface specifier，C++ 的 pure virtual function。通常接口类中强制的不能拥有实现，继承接口的子类至少享有两个名字，一个是自身定义的命名，一个是接口名。通常子类转父类（up-cast）在编译期（compile-time）决定，父类转子类（down-cast）在运行时（run-time）决定。</p>
<p>我们太过于习惯这种接口的方式，而这种接口方式也确实能十分灵活地应用在编程中，以至于我们常常不自觉的在设计中增加不必要的层数。如果你也喜欢 “flat is better than nested” 的理念的话，我接下来将会介绍两种 alternatives，用来代替传统的接口实现。</p>
<h2 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h2><p>使用 C 语言同样也可以进行 OOP，思路就是 function pointer。通过注册回调函数，用来替代传统的通过继承来实现接口。 C++11 所提供的 <code>std::function</code>，<code>std::bind</code> 和 lambda function 为此提供了极大的便利。</p>
<p>Example</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comparator</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">const</span> Slice &amp;, <span class="keyword">const</span> Slice &amp;)&gt; CompareFunc;</span><br><span class="line">  Comparator(<span class="keyword">const</span> CompareFunc &amp;compare_fn) :</span><br><span class="line">      compare_(compare_fn)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Three-way comparison.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;lhs,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compare_(lhs, rhs);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> CompareFunc compare_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每种 Comparator 的示例都可能实现某一种策略(Strategy)。而如果为每一个策略都定义一个子类，会将问题复杂化(flat is better than nested)。</p>
<h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><p>所有实例只能拥有父类的名字，不拥有自己的名字。当然设计上也不应该使实例拥有自己的名字。</p>
<h4 id="适用"><a href="#适用" class="headerlink" title="适用"></a>适用</h4><ul>
<li><a href="https://en.wikipedia.org/wiki/Strategy_pattern" target="_blank" rel="noopener">Strategy Pattern</a></li>
<li>可以通过 <a href="https://en.wikipedia.org/wiki/Decorator_pattern" target="_blank" rel="noopener">Decorator Pattern</a> 来进行向下扩展。</li>
</ul>
<h2 id="CRTP"><a href="#CRTP" class="headerlink" title="CRTP"></a>CRTP</h2><p>所谓接口其实是一种协议，换言之就是，继承接口的子类必须全部实现某些功能（函数），由于子类必须不可妥协地全部实现，因此从设计的角度讲，接口的粒度也应该越细越好。</p>
<p>为了某一个类去实现多个接口，可能不是一种干净的方法，因为这些接口将来可能不一定会被使用。C++ 的设计者为我们提供了无比强大的 template，用来更灵活地设计模块间关系。</p>
<p>CRTP，即 Curiously recurring template pattern。简单说就是将类自身作为自身模板的参数。 <code>boost::iterator_facade</code> 就利用了这种方法设计了一个 iterator 的抽象类，我们可以通过继承 <code>boost::iterator_facade</code> 轻易地实现一个 iterator。（吐槽一下，Boost.Iterator 这个库实在是太臃肿了，实际工程上完全可以写一个简易版本）</p>
<p>我们通过实现一个 IteratorFacade 来介绍这种方法，然而这种方法的实例较长，所以我们分开来讲。</p>
<h4 id="IteratorFacade"><a href="#IteratorFacade" class="headerlink" title="IteratorFacade"></a>IteratorFacade</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Derived</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">IteratorFacade</span> &#123;</span></span><br></pre></td></tr></table></figure>
<p>我们自己定义的 Iterator 只要继承 IteratorFacade 就能拥有一堆跟标准库容器一样的细枝末节的功能了（这些功能确实多而且杂）。我们首先假设 Iterator需要是一个 forward iterator。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>:</span></span><br><span class="line">    <span class="keyword">public</span> IteratorFacade&lt;</span><br><span class="line">        Iterator,</span><br><span class="line">        <span class="keyword">int</span>,</span><br><span class="line">        <span class="built_in">std</span>::forward_iterator_tag&gt; &#123;</span><br></pre></td></tr></table></figure>
<p>其中 Derived 参数就是 Iterator 自己了，而 int 对应的 T 参数表示这个 iterator 所指的值。</p>
<p>现在我们来仔细看看 IteratorFacade 的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Derived</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Category</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">IteratorFacade</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T&amp; Reference;</span><br><span class="line">  <span class="function">Derived <span class="title">Next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived tmp(derived());</span><br><span class="line">    IteratorCoreAccess::increment(derived());</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Facade</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">static</span> <span class="title">typename</span> <span class="title">Facade</span>:</span>:<span class="function">reference <span class="title">dereference</span><span class="params">(Facade <span class="keyword">const</span> &amp;f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f.dereference();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Reference <span class="title">Value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IteratorCoreAccess::dereference(derived());</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function">Derived &amp;<span class="title">derived</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">static_cast</span>&lt;Derived *&gt;(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里为了方便，我们使用 Next 而非 operator++（因为 ++ 操作符还分 postfix 和 prefix…），希望阅读到此处的读者不要奇怪。</p>
<h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><p>我们要在 IteratorFacade 中实现的就是，用户只需实现 increment，dereference 函数，并且将 IteratorCoreAccess 设为友元类，即可实现一个 forward iterator（Next()函数可用）。如果我们想要实现一个 bidirectional iterator，我们可以实现 decrement，这样 Prev()函数即可用。</p>
<p>这里的秘密在于 IteratorCoreAccess，由于其中的成员函数用 static 声明，例如只有在 decrement 被调用时，编译器才会去检查 Facade 类型是否具有 member function decrement。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IteratorCoreAccess</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">D</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">C</span>&gt; <span class="title">friend</span></span></span><br><span class="line"><span class="class">  <span class="title">class</span> <span class="title">IteratorFacade</span>;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Facade</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">static</span> <span class="title">void</span> <span class="title">increment</span>(<span class="title">Facade</span> &amp;<span class="title">f</span>) &#123;</span></span><br><span class="line">    f.increment();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Facade</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">static</span> <span class="title">void</span> <span class="title">decrement</span>(<span class="title">Facade</span> &amp;<span class="title">f</span>) &#123;</span></span><br><span class="line">    f.decrement();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Facade</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">static</span> <span class="title">typename</span> <span class="title">Facade</span>:</span>:<span class="function">reference <span class="title">dereference</span><span class="params">(Facade <span class="keyword">const</span> &amp;f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f.dereference();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Objects of this class are useless.</span></span><br><span class="line">  IteratorCoreAccess() = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相对于传统的 interface，这种方法（或者说设计模式）是强耦合的。它提供给用户有限的几种方案，用户根据自身需求（比如需要 forward iterator 还是 bidirectional iterator），实现相应的函数。</p>
<h4 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h4><ul>
<li>这种方法几乎没有多态可言，因为父类的名字不可被使用（由于模板参数的不同，IteratorFacade 的两个子类不一定享有同一个父类）。这导致一定程度上扩展性降低，适用于需求极其稳定的情形。</li>
<li>不可向下扩展。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>灵活性强。</li>
<li>简化了接口的设计。有点像 @叛逆者 曾经在知乎上回答的，游戏主机效率PC高的回答中提到的，把原先积木拼装结构，变成电焊焊死的，更加结实，也失去了可扩展性。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/01/writing_inet_address_in_cpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="neverchanje">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="neverchanje">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/01/writing_inet_address_in_cpp/" itemprop="url">用 C++ 写一个 Inet4Address 类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-11-01T00:00:00+08:00">
                2015-11-01
              </time>
            

            

            
          </span>

          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Inet4Address 在 .net 和 facebook/folly 中也叫做 IPAddress。<br>（顺便黑一下，muduo 中居然把 SocketAddress 叫做 InetAddress 真是有失偏颇。</p>
<hr>
<h2 id="构造ip-地址"><a href="#构造ip-地址" class="headerlink" title="构造ip 地址"></a>构造ip 地址</h2><p>ip 地址的构造，比较麻烦的地方就是网络序和主机序之间的问题。</p>
<p>我们的 raw ipv4 address 存储在一个 uint32_t 的整数中，按照 linux 官方手册中的描述，以下结构体表示 ipv4 address：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_addr; <span class="comment">/* address in network byte order */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>s_addr 是按网络序存储的，然而在下面的测试中，有与我预期不符合的地方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOST_AUTO_TEST_CASE(test_byteorder_inaddr) &#123;</span><br><span class="line">  in_addr addr;</span><br><span class="line">  inet_pton(AF_INET, &quot;192.168.0.1&quot;, &amp;addr);</span><br><span class="line">  BOOST_CHECK_EQUAL(addr.s_addr, 0x0100A8C0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我原先以为高位的 192 应该在 b3，而实际上在 b0。在 Java 中 的 <code>Inet4Address.getAddress()</code> 也有注释说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns the raw IP address of this &#123;@code InetAddress&#125;</span><br><span class="line"> * object. The result is in network byte order: the highest order</span><br><span class="line"> * byte of the address is in &#123;@code getAddress()[0]&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @return  the raw IP address of this object.</span><br><span class="line"> */</span><br><span class="line">public byte[] getAddress() &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（一开始没有理解这一点，我在 <code>s_addr</code> 存储的是 little-endian 值，以至于我引入了 redis 的 endianconv 作为工具函数，现在看来暂时没有用武之地了）</p>
<p>我们首先规定我们将使用 big-endian 存储 IP 地址，并统一使用</p>
<p>对于 IP 地址：b0.b1.b2.b3，我们用</p>
<ul>
<li><p>0x b3 b2 b1 b0 来构造大端序</p>
</li>
<li><p>0x b0 b1 b2 b3 来构造小端序</p>
</li>
</ul>
<p>我们允许使用者通过 Byte4 类型，也就是 <code>std::array&lt;uint8_t, 4&gt;</code> 作为参数来构造 Inet4Address，前提是 Byte4 参数是网络序：</p>
<p>即对于 “192.168.0.1”， b0 = 192, b1 = 168, b2 = 0, b3 = 1</p>
<p>我们也允许使用者通过 NBO 的 uint32_t 类型的地址进行构造，这时候我们该用 ntohl 或 htonl 来实现。</p>
<h2 id="特殊的-ip-地址"><a href="#特殊的-ip-地址" class="headerlink" title="特殊的 ip 地址"></a>特殊的 ip 地址</h2><ul>
<li><p>loopback address<br>环回地址。也就是127.0.0.1</p>
</li>
<li><p>link local address</p>
</li>
<li><p>multicast address</p>
</li>
<li><p>private address</p>
</li>
</ul>
<p>这些地址在代码注释中有提供描述他们的 RFC 文档。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因为理解的偏差，造轮子的时候走了一些远路（但不是歧路）：</p>
<ul>
<li><p>in_addr.s_addr 是否为 NBO</p>
</li>
<li><p>b0 为 ipv4 的高8位地址，而不是 b3</p>
</li>
<li><p>引入 redis 的 endianconv，写了一些无用代码，希望以后会派上用场。</p>
</li>
<li><p>当然还有阅读 RFC 文档，理解这些特殊 IP 地址的定义和用途。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/26/redis3.0-data-structures/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="neverchanje">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="neverchanje">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/26/redis3.0-data-structures/" itemprop="url">关于 Redis 3.0 中的数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-05-26T00:00:00+08:00">
                2015-05-26
              </time>
            

            

            
          </span>

          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Redis-是什么？"><a href="#Redis-是什么？" class="headerlink" title="Redis 是什么？"></a>Redis 是什么？</h2><p>Redis 官方网站：<a href="http://redis.io/" target="_blank" rel="noopener">http://redis.io/</a></p>
<h3 id="为什么要阅读-redis-的源代码？"><a href="#为什么要阅读-redis-的源代码？" class="headerlink" title="为什么要阅读 redis 的源代码？"></a>为什么要阅读 redis 的源代码？</h3><p>等价于问题：知乎：我们（大多数人）为什么喜欢造轮子？</p>
<p>redis 中有功能精简的模块，如 anet, ae，也有针对 redis 高度优化的数据结构模块，如 ziplist, dict, intset 等。这些模块相对易于学习，也非常有料。redis 本身就是一个相当优秀的开源作品，并且使用广泛，学习其中的实现，也能对 redis 有更深入的了解。</p>
<h2 id="简单开头"><a href="#简单开头" class="headerlink" title="简单开头"></a>简单开头</h2><p>Redis 对内存效率的要求常常会高于对时间效率的要求。所以接下来我们更多地会看到 redis 针对数据结构的内存上的优化。</p>
<h2 id="Data-Structure-1-adlist"><a href="#Data-Structure-1-adlist" class="headerlink" title="Data Structure #1: adlist"></a>Data Structure #1: adlist</h2><p>adlist 是 redis 实现的一个双向链表。算法原理和普通的双向链表一样。但是由于 C 语言没有复制构造函数之类的东西，所以深复制的实现要靠函数指针如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *(*dup) (<span class="keyword">void</span> *ptr);</span><br></pre></td></tr></table></figure>
<p>与之对应的还有深释放和深匹配（自己造的词）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*<span class="built_in">free</span>) (<span class="keyword">void</span> *ptr);</span><br><span class="line"><span class="keyword">int</span> (*match) (<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br></pre></td></tr></table></figure>
<h2 id="Data-Structure-2-intset"><a href="#Data-Structure-2-intset" class="headerlink" title="Data Structure #2: intset"></a>Data Structure #2: intset</h2><p>首先说明， intset 内部由数组实现。而 intset 顾名思义，只能够存放整数数组。但即使是整数依然有多种类型。uint32_t，int16_t，int8_t 等等。<br>由于 C 语言不具有多态，如果要一次性存放这些类型的数组，我们可以这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> *ui32;</span><br><span class="line">    <span class="keyword">uint16_t</span> *ui16;</span><br><span class="line">    <span class="keyword">int8_t</span>   *i8;</span><br><span class="line">    ....</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>
<p>虽然这样可以解决问题，但这显然是一种非常麻烦的方式。而且内存开销大。<br>redis 提供的思路是：<br>可以看出，一个 int16_t 可以用 2 个 int8_t 保存，同理地，一个 int32_t 可以用 4 个 int8_t 保存。所以，我们只需要一个 int8_t[] 数组即可。<br>我们给出结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个问题：如何知道 intset 中存储的值的类型？</li>
</ul>
<p>redis 用一个 encoding 值表示 intset 中值的类型。</p>
<ul>
<li>第二个问题：当值超过 int8_t 的范围，但在 int16_t 的范围内，如何对 intset 做出修改？</li>
</ul>
<p>重新调整 contents 数组的大小，以容纳 length 个 int16_t 值，并修改 encoding ，即：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">contents = <span class="built_in">realloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int16_t</span>) * length);`</span><br><span class="line">encoding = INTSET_ENC_INT16;</span><br></pre></td></tr></table></figure>
<p>intset 本身还提供了普通的 set 应有的特性，比如 有序性，唯一性。</p>
<h2 id="Data-Structure-3-ziplist"><a href="#Data-Structure-3-ziplist" class="headerlink" title="Data Structure #3: ziplist"></a>Data Structure #3: ziplist</h2><p>ziplist 是一个压缩的双向链表，只能储存整数和字符串。回想一下，一个双向链表节点的基本结构是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">void</span>* value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>
<p>看起来无法压缩，其实仔细观察会发现，prev 和 next 指针都会占用 8 bytes 的空间，可以从这里下手。简单设计一下，listNode 的内存布局可以是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|--int--|int|-----|</span><br><span class="line">|prevlen|len|value|</span><br></pre></td></tr></table></figure>
<p>假设指向当前节点的指针 p，当前节点的内存长度 len，那么下一个节点的指针 next 显然是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next = p + <span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>) + len;</span><br></pre></td></tr></table></figure>
<p>上一个节点的指针就是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prev = p - prevlen;</span><br></pre></td></tr></table></figure>
<p>这里简单概括一下这种设计的优缺点：首先内存开销降下来了，并且整个链表都可以放在一块连续内存块上，减少了内存碎片，顺便还能优化 cacheline，遍历的效率可以提升。然而这里失去了双向链表原有的优势，即快速插入删除节点。链表的插入删除仅需 O(1)，而这里需要 O(n)，和数组中间插入元素的道理是一样的。与其称它为 linked list，我更愿意称它 vector with variable-length elements。</p>
<p>这里还有一部分优化点：len 和 prevlen 都是固定长度（sizeof(int)），这样的设计对小 value 不友好。redis 的设计同样沿用上面的布局，并且针对 prevlen 和 len 做可变长度的优化，这部分比较复杂，prevlen 和 len 是分别处理的：</p>
<p>如果 <code>prevlen &lt; 254</code>，就把 prevlen 放在一个 byte 里，如果大于 254，就把 prevlen 放在 int 里，这两种情况的区分，用一个 one-char flag。不过 redis 更聪明的是，如果小于 254，prevlen 就直接放在 one-char flag。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">### prevlen &lt; 254</span><br><span class="line">|-uint8-|</span><br><span class="line">|prevlen|</span><br><span class="line">### prevlen &gt;= 254</span><br><span class="line">|-uint8-|--int--|</span><br><span class="line">|--254--|prevlen|</span><br></pre></td></tr></table></figure>
<p>len 的设计尤为复杂，值可能是 sds 或者整数，这两者有不同的编码方式。针对这个去讲述就非常无聊了，redis 在代码注释里已经全部列了出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">* |00pppppp| - 1 byte</span><br><span class="line">*      String value with length less than or equal to 63 bytes (6 bits).</span><br><span class="line">* |01pppppp|qqqqqqqq| - 2 bytes</span><br><span class="line">*      String value with length less than or equal to 16383 bytes (14 bits).</span><br><span class="line">* |10______|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes</span><br><span class="line">*      String value with length greater than or equal to 16384 bytes.</span><br><span class="line">* |11000000| - 1 byte</span><br><span class="line">*      Integer encoded as int16_t (2 bytes).</span><br><span class="line">* |11010000| - 1 byte</span><br><span class="line">*      Integer encoded as int32_t (4 bytes).</span><br><span class="line">* |11100000| - 1 byte</span><br><span class="line">*      Integer encoded as int64_t (8 bytes).</span><br><span class="line">* |11110000| - 1 byte</span><br><span class="line">*      Integer encoded as 24 bit signed (3 bytes).</span><br><span class="line">* |11111110| - 1 byte</span><br><span class="line">*      Integer encoded as 8 bit signed (1 byte).</span><br><span class="line">* |1111xxxx| - (with xxxx between 0000 and 1101) immediate 4 bit integer.</span><br><span class="line">*      Unsigned integer from 0 to 12. The encoded value is actually from</span><br><span class="line">*      1 to 13 because 0000 and 1111 can not be used, so 1 should be</span><br><span class="line">*      subtracted from the encoded 4 bit value to obtain the right value.</span><br><span class="line">* |11111111| - End of ziplist.</span><br></pre></td></tr></table></figure>
<p>这只是大概思路，具体实现还要考虑到很多细节，比较麻烦。</p>
<h2 id="Data-Structure-4-zipmap"><a href="#Data-Structure-4-zipmap" class="headerlink" title="Data Structure #4: zipmap"></a>Data Structure #4: zipmap</h2><p>与 ziplist 用的几乎是同样一种手段。zipmap 是一个压缩的 string key-value 数组。获取 value 的复杂度是 O(n) 的，因此适合数据不多的场合。</p>
<p>key-value 节点的结构是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;klen&gt;&lt;key&gt;|&lt;vlen&gt;&lt;free&gt;&lt;value&gt;</span><br><span class="line">----key----|-------value-------</span><br></pre></td></tr></table></figure>
<ul>
<li>Question：free 区有什么作用？<br>这要牵扯到 redis 处理内存和时间平衡的一个技巧。</li>
</ul>
<p>我们储存一个值 value，并为其分配长度为 len 的空间，这个值在动态改变的时候，占用的内存可能会变为 newlen。 如果 <code>newlen &lt; len</code> 意味着我们会多余出一些空间，这个空间记作 free。我们接下来可能要做两种操作：</p>
<ul>
<li>用 realloc 搭配 memmove 等操作将内存空间减少至 newlen</li>
<li>将这段多余的空间暂且放着，作为一段 free 空间。</li>
</ul>
<p>从时间效率考虑，后者肯定是最优的。（感觉解释起来有点麻烦）。但从内存效率考虑，前者肯定是最优的。</p>
<p>根据具体情况，我们可能只考虑前者（不考虑内存），或只考虑后者（时间要求不高），也可以综合考虑，设置一个参数 MAX_FREE_VALUE 表示最大能够容忍的 free 空间。如果超过了 MAX_FREE_VALUE 我们就把 free 空间腾出来。如果没超过，就暂且放着这块 free 空间。</p>
<h2 id="Data-Structure-5-dict"><a href="#Data-Structure-5-dict" class="headerlink" title="Data Structure #5: dict"></a>Data Structure #5: dict</h2><p>跟普通的 Hashtable 差不多，普通的 Hashtable 实现可参照 <code>java.util.Hashtable&lt;K,V&gt;</code></p>
<p>redis 中的 dict 进行了优化，也更复杂：</p>
<ul>
<li>一个 dict 其实维护了两个 Hashtable</li>
</ul>
<p>在 rehash 操作时，我们要进行 Hashtable 的迁移工作，这时候其实可以让两个 Hashtable 一起工作。比如查找节点时，在表1中找不到，则去表2中找。这样允许我们可以不必在 rehash 的时候一次性完成全部的迁移。</p>
<ul>
<li>渐进式 rehash</li>
</ul>
<p><strong><em>为什么要使用渐进式 rehash ？</em></strong></p>
<p>显然，rehash 操作是整个 hashtable 的瓶颈。可以采用分摊的思想，将 rehash 操作分摊给其他操作。比如分摊给 dictAdd, dictFind, dictDelete, dictReplace。由于这些操作平均复杂度都是 O(1) 的，所以每个操作都只能分摊一次 rehash 操作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="neverchanje" />
            
              <p class="site-author-name" itemprop="name">neverchanje</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/neverchanje" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">neverchanje</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
