<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans,en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="neverchanje">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="neverchanje">
<meta property="og:locale" content="zh-Hans,en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="neverchanje">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>neverchanje</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans,en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">neverchanje</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/27/morning_paper_optimizing_space_amplification_in_rocksdb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="neverchanje">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="neverchanje">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/27/morning_paper_optimizing_space_amplification_in_rocksdb/" itemprop="url">Morning Paper - optimizing space amplification in rocksdb</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-27T00:00:00+08:00">
                2018-06-27
              </time>
            

            

            
          </span>

          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>其实是一个比较小众的需求：我们的机器 cpu 和 ssd 处理能力充裕，实在是磁盘空间不够。所以需要想方设法把空间利用率提上来，但要尽可能少的影响读写。</p>
<p>这个需求建立在一个前提下：fb 有一层大规模分布式 cache 层承担绝大部分请求，所以落到 rocksdb 的 query 不多。（不知道什么 workload 非得加 cache 层）</p>
<p>几种策略：</p>
<h2 id="Key-prefix-encoding"><a href="#Key-prefix-encoding" class="headerlink" title="Key prefix encoding"></a>Key prefix encoding</h2><p>这个是 leveldb 就有的优化，相邻 key 共享 prefix，不提。</p>
<h2 id="Tiered-compression"><a href="#Tiered-compression" class="headerlink" title="Tiered compression"></a>Tiered compression</h2><p>其实就是加压缩，但是不在 level 0-2 加压缩，因为这样会影响读性能。只在 level &gt; 2 加压缩，因为层数高的数据访问频率小。我们知道这个配置项就是 compression_per_level。</p>
<h2 id="No-bloom-filter-for-last-level"><a href="#No-bloom-filter-for-last-level" class="headerlink" title="No bloom filter for last level"></a>No bloom filter for last level</h2><p>最后一层的数据量比前几层加起来都多，访问频率又低，所以省掉 bloom filter block 可以省掉许多存储空间。这个相关的配置项没找到。</p>
<h2 id="dynamic-level-compaction"><a href="#dynamic-level-compaction" class="headerlink" title="dynamic level compaction"></a>dynamic level compaction</h2><p>这个选项其实是 level_compaction_dynamic_level_bytes ，是一个 advance option，facebook/rocksdb 这里是这个 feature 发布时的官方博客。它的思想是从 space amplification 的理论入手来节约空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">space amplification = space on filesystem / space of user data</span><br></pre></td></tr></table></figure></p>
<p>考虑在一个理想稳定的 workload 下，用户数据长期稳定不变，只有少量增删和更新，此时 last level 和用户数据量相近，故<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">multiplier = 10，Lx = last level</span><br><span class="line">space amplification = (L0 + L1 + ... Lx) / Lx = 1 + 0.1 + 0.01 ... = 1.11</span><br></pre></td></tr></table></figure></p>
<p>然而通常 last level 填不满，对于 Lx = 2 Lx-1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">space amplification = (Lx + 0.5Lx + 0.05Lx + ... ) / Lx = 1.55</span><br></pre></td></tr></table></figure></p>
<p>所以如果 last level 填不满，就自适应地把 level 调小，就能够接近最优空间放大 1.11。</p>
<h2 id="compression-dictionary"><a href="#compression-dictionary" class="headerlink" title="compression dictionary"></a>compression dictionary</h2><p>有些压缩算法支持全局 dictionary 来提高压缩率。相关配置是 <code>CompressionOptions::max_dict_size</code>。不太懂这个。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/24/morning_paper_wisckey/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="neverchanje">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="neverchanje">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/24/morning_paper_wisckey/" itemprop="url">Morning Paper - WiscKey, Separating Keys from Values in SSD-Conscious Storage</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-24T00:00:00+08:00">
                2018-06-24
              </time>
            

            

            
          </span>

          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>记录一些 yy 的想法，不值一提。</p>
<h2 id="vlog"><a href="#vlog" class="headerlink" title="vlog"></a>vlog</h2><p>对分布式 KV 来讲，能不能把 vlog 用作为 paxoslog？</p>
<p>我所知的两种基于 rocksdb 的典型 KV store 是这样做的：</p>
<ul>
<li><p>像 tikv 这样的每次写数据要先写 raftlog，然后写 rocksdb WAL，最后写 rocksdb memtable。一条 value 相当于写 3 次。由于所有 replica 共享一个 rocksdb 实例，所以必须要维护 raftlog。</p>
</li>
<li><p>pegasus 和 tikv 类似但是关掉了 rocksdb WAL，只写 paxos log。当 rocksdb memtable flush 到 L0 的时候，相应的 paxos log 才可以被 GC。这种方案需要改 rocksdb 代码，但会优于 tikv，一条 value 只需要写 2 次。pegasus 的每个 replica 都独有一个 rocksdb 实例。</p>
</li>
</ul>
<p>现在 wisckey 来了，先写 vlog，再写 LSM index，总的数据只需要写一次。如果用在 tikv 上，WAL 可以省掉，只需维护 raftlog 和 vlog，数据只需写 2 次。如果用在 pegasus 上，paxos log 和 vlog 的合并需要一些改动，因为：</p>
<ol>
<li><p>wisckey 的 delete 不写 vlog，只改 LSM index，为了用作 paxoslog，delete 可以改为写 tomb record 到 vlog 中。</p>
</li>
<li><p>wisckey 的 vlog 不维护顺序性，在 GC 过程中，一些 record 可能会从 tail 移到 head。所以需保证未提交的日志不可被 GC。</p>
</li>
</ol>
<p>如果能够合并，那数据总的只需要写一次。不过从工程角度讲，合并 paxos log 和 vlog 应当还有更多细节。</p>
<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>然后我们看看使用 wisckey 是否能获得稳定性提升：</p>
<p>rocksdb 有个问题就是当 writes 过多的时候容易出现 <strong>write stall</strong>，意为后台来不及 GC 导致 L0 文件数接近上限（<code>level0_file_num_compaction_trigger</code>），只好延阻写。众所周知 L0 的 read 最坏需要遍历所有文件，所以 L0 的文件数上限也不能过大。</p>
<p>由于这个问题，rocksdb 在大量写的场景写需要调整业务，使用某种读写分离的方案。</p>
<p>Wisckey 能够解决这个问题：因为 wisckey 高吞吐读写时完全可以不做 GC，最多是空间消耗大，而 rocksdb 不做 GC 则会直接影响读性能。</p>
<p>当然 wisckey 的后台 GC 也会影响前台工作，这点需要工程实践的权衡。</p>
<h2 id="Inline-Storage"><a href="#Inline-Storage" class="headerlink" title="Inline Storage"></a>Inline Storage</h2><p>LSM 在小 value （通常小于 128 bytes）的场景下表现优于 wisckey，然而在大 value 下表现劣于 wisckey，所以可以把短 value 直接存在 LSM tree 里。如果 DB 内全都是短 value，那么它就完全退化成 LSM。如果 value size 普遍是大 value，那么 wisckey 的性能优势就能体现出来。</p>
<p>这种方案完美地融合 LSM 和 wisckey 的长处，工业价值很高。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/19/morning_paper_write_behind_logging/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="neverchanje">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="neverchanje">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/19/morning_paper_write_behind_logging/" itemprop="url">Morning Paper - Write-Behind-Logging</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-19T00:00:00+08:00">
                2018-06-19
              </time>
            

            

            
          </span>

          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>理论上我们可以直接把数据写入 nvm，但是由于 nvm 和 dram 之间还有较大性能差距，我们会先把数据缓存在 dram，再写入 nvm。这样的架构称作 two-tier-hiarachy。</p>
<p>数据首先缓存在 dram 中的 DTT（dirty-tuple-table），在提交的时候，统一刷入 nvm。具体过程分为：</p>
<ul>
<li><p>write nvm table heap</p>
</li>
<li><p>nvm sync</p>
</li>
</ul>
<p>如果在 nvm sync 之前机器挂了，nvm 里面就会有脏数据。WBL 的做法是写一条日志表示 “我是现在最新的提交，往后 100 条写都是脏的”。（100 这个值可配）。</p>
<p>基于这个设计，WBL 的提交过程是：</p>
<ul>
<li><p>write nvm table heap</p>
</li>
<li><p>nvm sync</p>
</li>
<li><p>write WBL</p>
</li>
<li><p>nvm sync</p>
</li>
</ul>
<p>所以每次读的时候，需要注意不去读脏数据。如何避免脏数据？WBL 假设 DB 使用 timestamp 来标记写（MVCC）。假如当前提交至 300，那么 timestamp 在 [301, 400] 之间的写则全都会认为是脏的。</p>
<p>recovery 时脏的写会被 abort。对于这些脏数据，DB 在 timestamp GC 的时候可以顺便清理。</p>
<p>有一个严重问题是如何实现 log replication。以前的 replication 从没考虑过 NVM 这种超强存储，这样 Paxos（synchronous replication）这种先提交日志，再写 DB 的模型无法发挥 WBL 的最大威力。因为即便 NVM 效率再高，日志 WAL 也要先提交到 3 副本。相信后面会有基于 RDMA 和 NVM 的 Paxos 工作出现。</p>
<p>对于空间使用率上：</p>
<ul>
<li><p>WBL 不需要 checkpoint（WAL 模型下为了减少日志，加快 recovery）</p>
</li>
<li><p>永远只需要维护极少量 log</p>
</li>
<li><p>DB data structure 也可以优化空间使用</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/25/raft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="neverchanje">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="neverchanje">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/25/raft/" itemprop="url">快速理解一致性协议 raft</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-25T00:00:00+08:00">
                2017-10-25
              </time>
            

            

            
          </span>

          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>为了更好地拉人入坑，我决定写篇关于 raft 的教程出来，尽可能深入浅出一些，让甚至是没接触分布式系统的同学也能理解。paper 还是要看的，只不过这篇文章希望做一个概览。</p>
<p>继续广告，我的项目在：</p>
<p><a href="https://github.com/neverchanje/yaraft" target="_blank" rel="noopener">neverchanje/yaraft</a></p>
<p><a href="https://github.com/neverchanje/consensus-yaraft" target="_blank" rel="noopener">neverchanje/consensus-yaraft</a></p>
<hr>
<p>Raft 解决的问题很简单，就是让多个副本的日志数据达成一致。举个例子，就是地球上发生了几个事件，称作 {1,2,3}。A 是某国家主席（称为 leader），它得知事件是 {1,2,3}；B, C 是香港记者（称为 follower），它们只知道事件 {1,2}。如何让 A, B, C 对事件集合达成一致，就是 Raft 所需要解决的问题。</p>
<p>很简单的，leader 需要告知其他 followers，发生了事件 3，并且它发生在事件 1,2 之后。</p>
<p>接下来正经点说。</p>
<p>分布式系统里，机器时不时就会崩，网络时不时就会抖。当然如果你把 timeout 设置到 10s，出错的概率其实不会很高，但这就意味着你的系统有最高 10s 的不可用时间。</p>
<p>所以我们引出了几个需求：</p>
<ul>
<li><p>数据不能丢，需要多节点备份</p>
</li>
<li><p>有一定的容错能力（fault tolerance），少数节点的网络抖动不会对多数节点造成影响。</p>
</li>
</ul>
<p>这个问题发展出了一套理论，我只简单地讲讲：</p>
<ol>
<li><p>考虑 2N+1 个节点。一份数据，至少需要复制到 N+1 个节点上才算是提交（commit），否则可能出现冲突。比方说事件 x=1 发到 N 个节点，同时事件 x=2 发到另外 N 个节点。如果 x=1 和 x=2 同时提交了，最终 x 的值是多少很难说清。这和多线程锁是一样的。2N 个节点的情况也同理。</p>
</li>
<li><p>一份数据复制到 N 个节点上，如果要容忍 K 个错误，需要 <code>K &lt; N</code>，这样才能保证复制到 N 个节点满足数据提交的要求。也就是说，N 个节点，最多容忍 N-1 个错误。</p>
</li>
</ol>
<p>我也时常在想一个问题，为什么多数一致性协议都要求过半节点复制成功才算提交？3 个节点，复制到 2 个才算提交（2/3）；5 个节点，复制到 3 个才算提交（3/5）。为什么没有一个专门优化 4/6 或者 4/5 的协议？</p>
<p>我觉得可能是“过半”这个 constraint 足够松，它能够最大程度容忍错误，能够最小程度上保证提交。</p>
<p>思考日志分发（log replication），可以围绕这个简单点考虑：</p>
<p><strong>leader 将日志发给 follower，过半就算提交。</strong></p>
<p>假设 5 个节点，假设 leader 永远在任，那么除非有 3 个 followers 全部失效，否则系统没有问题。follower 一切坚持以 leader 为主导，深入贯彻其基本思想，只要 leader 是对的，即便有 follower 赶不上，leader 也能把它往前拉。</p>
<p>然而 leader 也是会意外下马的（比如陈水扁），一旦 leader 出事，问题就来了。上一任 leader 说过的话，算不算数呢？应该听当前这一任 leader 的，还是听上一任的？</p>
<p>我们为每一届选举，标记一个任期 term。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A (Leader): &lt;index: 1, term: 2&gt; &lt;index: 2, term: 2&gt; &lt;index: 3, term: 3&gt;</span><br><span class="line">B (Follower): &lt;index: 1, term: 2&gt; &lt;index: 2, term: 2&gt; &lt;index: 3, term: 2&gt;</span><br><span class="line">C (Follower): &lt;index: 1, term: 2&gt; &lt;index: 2, term: 2&gt;</span><br></pre></td></tr></table></figure>
<p>A 当选了新的 leader，他是在第三届选举当选的，所以当前 term 为 3。B，C 为 follower。A 和 B 存在冲突。A 认为地球上发生了三件事，第三件事是在 term=3 的时候发生的，而 B 认为第三件事是在上一任 leader 在的时候（term=2）发生的。</p>
<p>因为 A 有最大话语权，所以 B 只能乖乖听话，修改记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B (Follower): &lt;index: 1, term: 2&gt; &lt;index: 2, term: 2&gt; &lt;index: 3, term: 3&gt;</span><br></pre></td></tr></table></figure>
<p>Raft 的选举也是如日志分发类似，过半节点认同候选人（candidate），它才能当选 leader。</p>
<p>过程大概是 candidate 发起投票，follower 可以投同意票，也可以投反对票。过半的 follower 同意，则 candidate 当选为 leader。</p>
<p>显然，这样每一届选举，只能选出一个 leader。</p>
<p><strong>群众要为选举出来的 leader 负责。</strong></p>
<p>假设 A, B, C 把 C 选举出来作为 leader，那么惨剧就目不忍视了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A (Follower): &lt;index: 1, term: 2&gt; &lt;index: 2, term: 2&gt; &lt;index: 3, term: 3&gt;</span><br><span class="line">B (Follower): &lt;index: 1, term: 2&gt; &lt;index: 2, term: 2&gt; &lt;index: 3, term: 3&gt;</span><br><span class="line">C (Leader): &lt;index: 1, term: 2&gt; &lt;index: 2, term: 2&gt;</span><br></pre></td></tr></table></figure>
<p>虽然 <code>&lt;index: 3, term: 3&gt;</code> 这条日志已经提交（复制过半），C 依然会无情地将它们抹去。</p>
<p>这是不合理的。好比如 A 和 B 在 <code>&lt;index: 3, term: 3&gt;</code> 确立了社会主义，结果 C 一上来就要改革为农奴制，而没有取得 A, B 的共识。</p>
<p>所以在 Raft 中，C 是永远不能当选为 leader 的。A, B 会认为 C 不够新。过半的节点认为它不够新，C 就不可能当选。</p>
<p>考虑网络的异步化，真实网络很难让我们再用现实世界举例。现实中上一任主席通常不会对当下的国家再下命令（垂帘听政的意思），而网络中却时有发生。</p>
<p>比如第三届选举当选的主席，却收到第二届选举发起的投票，这是不合常理的。这时候它不会去投票，而是会直接无视。</p>
<p>所以，term 就成了是否忽略消息的重要依据。每个节点都具有一个属性，称为 currentTerm，每条消息都会携带发送者的 term。收到任何消息时，节点都会判断消息是否来自于以前的 term（<code>term &lt; currentTerm</code>），如果是的话，直接无视。</p>
<p>term = 3 的节点收到消息 term=5，这意味着什么？意味着：</p>
<p>节点长期与其他节点隔离，以至于第四届，第五届选举时，投票没有通知他。</p>
<p>即便它贵为 term=3 的 leader，如今它也应该下台做 term=5 的 follower。</p>
<p>考虑网络异步化，我们重新整理 leader 选举的过程。</p>
<p>candidate 发起投票，消息中会携带它的 currentTerm。它可能出现 term 过低，被人无视的处境。此时 candidate 的本届选举相当于失败，它应当进行下一届选举（curentTerm++）。因为他坚信，leader 已经下台了。</p>
<p>follower 收到 candidate 的投票，如果投票的 term 足够大（比如 currentTerm=2，消息 term=3），follower 就会同意，并将自己的 currentTerm 设为 3。</p>
<p><img src="http://og0xhkmh3.bkt.clouddn.com/raft/campaign.jpg" alt=""></p>
<p>（term = 3 的 candidate 发起投票，S2，S3，S5 同意）</p>
<p>candidate 收到过半的 follower 同意，则它当选 leader。</p>
<p>好了，我们再整理一个问题：candidate 发起投票，原因是 leader 下台，需要换届。而它又是如何得知 leader 是否下台的？</p>
<p>在平时，leader 会发送心跳（heartbeat）给所有 followers，告诉它们自己还活着。一旦 leader 失效，followers 没有收到心跳，那么它们自然会选举出新的 leader。</p>
<p>所以可能某个 candidate 发起投票，却被所有人无视，但只要他坚信 leader 已经下台（没收到任何来自 leader 的消息），那么他依然会发起新的选举。</p>
<p>到此这篇教程就结束了，Raft 论文中还有一些需要体会的内容，但对初识一致性协议的同学来说不那么重要。文章中有错误的地方欢迎指正，有不理解或者批评的地方也欢迎提出。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/19/record_before_graduation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="neverchanje">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="neverchanje">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/19/record_before_graduation/" itemprop="url">记大学毕业前的阴霾事件</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-19T00:00:00+08:00">
                2017-08-19
              </time>
            

            

            
          </span>

          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在东南大学这种破学校毕业简直就是耻辱。先在这记个日记，某天写长博喷。</p>
<p><img src="http://og0xhkmh3.bkt.clouddn.com/seu_graduation_paper.png" alt=""></p>
<p>三个所谓专家在跟前批判毕设，先是说论文摘要不能用 “我们”，一定要以第三人称视角讲述，说是没见过论文里用 “我们” 的。后来怼回去说我答辩前还在看最近正火的 WiscKey 的 paper，摘要里那么多 “We” 是怎样，你敢说人家错了吗。结果我当然是被批判一番。</p>
<p>后来说论文里不能用太新潮的词，什么 “算法没有银弹”，专家说 “银弹” 这词太潮了，不该写论文里。qnmd “银弹” 还潮，这句话我还是借鉴某篇论文学来的呢。</p>
<p>接着批判说为啥子你的论文没有个结果呢，我说这是 library 啊，全部测试通过，travis-ci passed 算不算数。它说你这样不行的，naive，人家毕业论文起码都要写个命令行的输出上去，把命令行截图截到论文里，有没有意义另说，起码人家知道你做出来结果了。</p>
<p>我当时傻了眼了，对着这头牛一样的专家叨叨，我这架构图也好，优化策略也好，部分详细设计也好，代码也开源了，还不行么。结果这货还笑着，对我说了句：你为什么就不能像其他人一样写篇八股文呢。</p>
<p>wqnmgb。</p>
<p>老子他妈辛辛苦苦做了的事，你不看，懒得看，我没意见，毕竟项目还有的做的呢。然而你非得捡些有的没的，干扰我毕业，显示你那点微薄的能力，这是带着恶的教育。</p>
<p>最后跟我说你们台湾人要按着这边的格式写，这边论文不这么写的。</p>
<p>我说不好意思，我是福建厦门人（大雾）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/03/consensus-yaraft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="neverchanje">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="neverchanje">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/03/consensus-yaraft/" itemprop="url">consensus-yaraft</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-03T00:00:00+08:00">
                2017-08-03
              </time>
            

            

            
          </span>

          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>consensus-yaraft 是一个基于 Raft 协议 [6] 的分布式组件，它使用 C++ 实现，目的是消除 pegasus [2] 对 zk 的依赖。</p>
<p>我们首先对 Raft 状态机进行解耦，开发了 yaraft [3]。它仅实现了协议部分，而将网络和存储部分作为接口给上层实现，这种方式可以方便我们抛开存储和网络，对协议的实现进行充分测试。在 yaraft 的基础之上，我们对 RPC 和 WAL 进行了实现，这就是现在的 consensus-yaraft。</p>
<p>当前项目尚未投入使用，但一直以开源项目[1] 的形式持续在开发中。</p>
<h2 id="yaraft"><a href="#yaraft" class="headerlink" title="yaraft"></a>yaraft</h2><p>yaraft 是 Raft 协议模块的实现。yaraft 起初是从 etcd/raft [4] 移植而来。etcd 作为一个被广泛使用的开源项目，其代码质量相对较高，单元测试也相对充足。我们除了移植 etcd/raft 的代码，也移植了它的单元测试，从而保证 yaraft 同样具有相对高的鲁棒性。</p>
<p>一般实现 consensus 有这样一种思路：节点发消息的过程称作一个 ConsensusRound，发出消息后，异步地等待结果。比如 leader 发日志，它首先广播 AppendEntries，然后异步等待。RPC 线程收到 AppendEntries Response 后提醒 leader。如果 leader 收到过半的结果（可能是过半的拒绝，也可能是过半的同意），则该轮 ConsensusRound 结束。</p>
<p>这里涉及到一个 ConsensusRound 生命周期管理的问题，一个 leader 如何异步等待的问题。这些还算简单（事实上 kudu[7] 的 consensus 就是这样实现的）。</p>
<p>还有一个问题是如何进行测试，如何构建一个本地 raft 集群。强行起多个进程，自然非常麻烦。构建一个 network simulator，节点间通过 network simulator 传输消息也是一个办法，不过这需要一些工作量。network simulator 的工作很有意义，但它的问题在于，假如我们想要模拟节点在接收到特定顺序消息时的行为时，整个过程非常麻烦。</p>
<p>不理解这一点的，可以在 <a href="https://raft.github.io" target="_blank" rel="noopener">https://raft.github.io</a> 的 visualization demo （这就是一个 network simulator）上尝试让某一节点写入你所想要的日志序列。尝试一番你就会知道，这并不是随心所欲的。比如要写 {index:1, term:1}, {index:2, term:2}，你可能要让一个 leader 节点先发来 {index:1, term:1}，然后重新选举，term 升高为 2，再发送 {index:2, term:2}。</p>
<p>当然这些只是我个人的理解，我并没有实现过这样架构的 consensus，我只是想表明，yaraft 的设计可以解决这些问题，而且更简单。</p>
<p>raft、paxos 协议的目的是解决异步网络下的一致性问题。在异步网络中，消息的先后顺序不定，唯有的是因果关系。这种场景下适合使用状态机来解决问题。所以在 yaraft 中，我们采用这样的架构：消息驱动状态机转移，状态机会产生新的消息发送给其他节点。</p>
<p>这种架构面对上面的问题就有很大的优势了：要给某个节点写入 {index:1, term:1}, {index:2, term:2}，我们只需要创建一个节点，不需要 network simulator，不需要集群，然后对它发消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;type: MsgApp, entries: [&#123;index:1, term:1&#125;, &#123;index:2, term:2&#125;</span><br></pre></td></tr></table></figure>
<p>yaraft 的大致工作流程如下：</p>
<p>Raft 状态机接收到消息，经过一段状态转移后，产出一系列输出。</p>
<p>其中一些输出指的是需要持久化的状态，这些输出会存在 HardState 中。对每个产出 HardState 的状态转移，我们都要在转移后将 HardState 的内容持久化。在持久化之前，该转移不被认为成功。</p>
<p><img src="http://og0xhkmh3.bkt.clouddn.com/consensus-yaraft/overview/image_0.png" alt="image alt text"></p>
<p>HardState 包括了 currentTerm，votedFor，还有 committedIndex</p>
<p>状态机还会对一些请求类的 RPC 产出响应 RPC。例如在接受 MsgApp 消息后，状态机会发回 MsgAppResp；收到 MsgVote，也会发回 MsgVoteResp。响应产出后，我们需要将它们发到指定的对端节点。</p>
<p>日志项会先写入 Unstable，只有这些日志项持久化了，才会写入 MemoryStorage。</p>
<p><img src="http://og0xhkmh3.bkt.clouddn.com/consensus-yaraft/overview/image_1.png" alt="image alt text"></p>
<p>我们如何使用 yaraft：首先通过调用 RawNode::Step 来驱动状态机转换，通过 RawNode::GetReady 来获取即将被持久化和网络传输的数据。</p>
<p>在获得 Ready 对象之后，用户首先将 Ready::entries 和 Ready::hardState 分别进行持久化，然后将 Ready::message 发送到其他节点上。此次请求处理即可视作完成。</p>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>这里的 RPC 指的是两个 Raft 节点之间的网络传输。在 consensus-yaraft 中，我们基于 baidu/sofa-pbrpc[5] 实现 RPC 层。</p>
<h2 id="异步通信模型"><a href="#异步通信模型" class="headerlink" title="异步通信模型"></a>异步通信模型</h2><p>考虑一个问题，leader 向 follower 发送 AppendEntries 请求，follower 收到后进行状态转移，数据持久化，然后发回 AppendEntries Response，整个过程 leader 同步阻塞。而 Raft 假设整个网络是异步化的，所以我们进行一点修改：</p>
<p>leader 向 follower 发送 AppendEntries，follower 接收到消息后，经过状态机处理，即发回 consensus.rpc.pb.StepResponse（简称 Reply），其中包含状态码等信息。此时 leader 不等待 follower 的数据持久化，只是异步等待 Reply 发回。（TODO：暂时没有想要 Reply 报错时如何处理）</p>
<p>在 leader 收到 follower 发回的 AppendEntries Response 后，leader 也应该发送 Reply。由此整个通信过程完成异步化。</p>
<h2 id="Background-Timer"><a href="#Background-Timer" class="headerlink" title="Background Timer"></a>Background Timer</h2><p>Raft 协议需要计时器来定期执行心跳和选举超时的判断。设计上我们需要一个后台计时器，每隔 100ms 驱动状态机执行 1 次 RawNode::Tick 的操作。</p>
<p>考虑到多 Raft 节点部署的场景，BackgroundTimer 设计上支持多个 raft 节点共享一个 timer。</p>
<h2 id="RaftTaskExecutor"><a href="#RaftTaskExecutor" class="headerlink" title="RaftTaskExecutor"></a>RaftTaskExecutor</h2><p>为了避免不必要的锁竞争，我们让 Raft 的状态机永远是单线程运行。timer，rpc，wal write 都会把任务放到 RaftTaskExecutor 执行，同一时间只有一个任务正在执行。</p>
<p>RaftTaskExecutor 含有一个 TaskQueue，这是真正工作的任务队列，我们使用 moody camel 的并发队列实现[8]。</p>
<p>考虑到多节点部署在同一机器上，如果每个节点都需要一个 TaskQueue 线程，那 100 个节点占 100 个线程是十分浪费的。所以我们允许多个节点使用一个 TaskQueue。正确的使用姿势是每个 CPU 分配一个 TaskQueue，不过我们现在还没考虑这个问题。</p>
<p><img src="http://og0xhkmh3.bkt.clouddn.com/consensus-yaraft/overview/image_2.png" alt="image alt text"></p>
<h2 id="ReadyFlusher"><a href="#ReadyFlusher" class="headerlink" title="ReadyFlusher"></a>ReadyFlusher</h2><p>最开始处理 Ready 的逻辑是，每次 RaftTaskExecutor 处理任务，就判断是否有新的 Ready 生成，如果有的话，就异步进行处理（推到线程池，这是 “push” 的思路）。</p>
<p>ReadyFlusher 最初的设计目的很简单，我认为 Ready 应该用 “pull” 的方式，从 raft node 上拉取下来。一方面这样可以让多份消息只写一次 Ready，一方面 ReadyFlusher 可以起到调配系统资源的效果，从而最优化处理 Ready。当然现在实现上比较差劲，而且 “pull” 和 “push” 的效果不见得有太大分别。</p>
<p>比较意外的 bonus 是 Ready 处理这部分的逻辑从 RaftTaskExecutor 上解耦，设计和单测上都舒服很多。</p>
<p>因为多节点部署问题，ReadyFlusher 也支持多节点共享。</p>
<h2 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h2><p>架构上我们将基于 Raft 的分布式存储分为两个部分，一个是 DataStore（比如内存的 KV 键值对存储），一个是 LogStore。日志即 WAL。节点间的 WAL 通过 Raft 协议保持一致。</p>
<p>每个 AppendEntries 都会携带一串 log entries 来到指定 Raft 节点，然后该节点将其写入 WAL。为了避免 WAL 无限增加，通常需要进行日志清理。一种清理方法是将 DataStore 的内容打成快照，然后将对应 WAL 删除，这种方法称作 Snapshotting。现在我们只考虑这种方案。</p>
<p><img src="http://og0xhkmh3.bkt.clouddn.com/consensus-yaraft/overview/image_3.png" alt="image alt text"></p>
<h2 id="日志后缀随机读写"><a href="#日志后缀随机读写" class="headerlink" title="日志后缀随机读写"></a>日志后缀随机读写</h2><p>在 Raft 协议中，由于网络分区等原因导致的日志不一致，follower 的日志后缀可能被 leader rewrite。rewrite 的过程涉及到一次随机读，定位到 conflicting log index 所在的文件 offset，然后执行 truncate 操作截断文件后缀，再将新日志项写入。</p>
<p><img src="http://og0xhkmh3.bkt.clouddn.com/consensus-yaraft/overview/image_4.png" alt="image alt text"></p>
<p>实践证明这种方案不光性能差（涉及到随机读写），而且实现也比较麻烦（看上去简单）。所以与其如此，我们考虑一种优化方案。</p>
<p><img src="http://og0xhkmh3.bkt.clouddn.com/consensus-yaraft/overview/image_5.png" alt="image alt text"></p>
<p>实际上我们并不需要删掉 conflicting log entries，我们可以保留它们，然后将新的日志 append 到末尾。</p>
<p>可能会有人认为这样不符合 Raft 的正确性，其实不然。在我们的设计中，所有的 WAL 都会同时存在内存（被称为 MemoryStorage）和磁盘中。WAL 在内存中的存储不用考虑随机读写，怎么正确怎么来即可。状态机在任何时候，都只会从 MemoryStorage 中读取日志，所以不用担心磁盘存储对正确性的影响。磁盘存储的 WAL 只负责 recovery。这样，如何从磁盘中正确地读取 WAL 到 MemoryStorage 中，就成为了正确性的关键问题。</p>
<p>对于上图 follower 的 [1, 1, 1, 2, 3, 3, 3, 4] 日志集，在 recovery 时，我们可能发现 {index=7, term=3} 的日志项的 index 比 {index=5, term=4} 的日志项的 index 小，这是不符合 Raft 正确性的，所以我们认为 {index=7, term=3} 是坏的，可以删掉。依次倒推，{index=6, term=3} 和 {index=5, term=3} 的日志项也是坏的，同样删之。最终我们可以读到正确日志集 {1, 1, 1, 2, 4}。</p>
<h2 id="日志前缀随机读写"><a href="#日志前缀随机读写" class="headerlink" title="日志前缀随机读写"></a>日志前缀随机读写</h2><p>日志肯定需要被清理，如果要删除日志文件的前缀，也会涉及到一次随机读写。</p>
<p><img src="http://og0xhkmh3.bkt.clouddn.com/consensus-yaraft/overview/image_6.png" alt=""></p>
<p>首先我们肯定只会清理掉 committed 的日志项。首先把 uncommitted 的日志项复制到新文件中（WAL-02），然后将原日志文件删除（WAL-01）。这种做法首先要定位 first uncommitted log entry 的文件 offset（这涉及到一次随机读），然后一次数据复制和一次数据删除。</p>
<p>很显然这种方式性能差，实现也麻烦。因此我们采用 segmentation 的方式。</p>
<p><img src="http://og0xhkmh3.bkt.clouddn.com/consensus-yaraft/overview/image_7.png" alt=""></p>
<p>日志集写入过程中，会被分成多个固定大小的 segment。每填满一个 segment，数据就会被塞到新的 segment 中。</p>
<p>在日志清理时，我们只需要删掉那些 committed 的 segment 即可。</p>
<h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>有必要说一下集成测试。<br>consensus-yaraft 的集成测试大致是这样：首先建立一个本地集群，任意为其写数据，或者杀死某一节点，然后检查状态是否正确。<br>本地集群采用多进程模型，避免线程之间互相影响。对于集成测试使用多线程是否足够？答案是否定的。首先多线程 raft servers 需要共享 gflags，这点在实现上会造成麻烦。其次是我们总有一天需要进行多进程下的测试，与其现在使用”简单的”多线程模型，不如早点为多进程模型铺路。<br>为什么我们会对多进程产生烦恼？其实是因为 C++ 缺少一个好用的进程库（类似于 python subprocess），而从头写一个进程库并没有我们想象中那么简单（参照 <a href="https://github.com/cloudera/kudu/blob/master/src/kudu/util/subprocess.h" target="_blank" rel="noopener">https://github.com/cloudera/kudu/blob/master/src/kudu/util/subprocess.h</a> ）。基于这个现实，我们使用 python 实现集成测试。未来类似 failover test 也可以用 python 实现。<br>使用 Python 的坏处是对开源用户不太友好，需要多进行一些配置。然而作为开发者是很爽的。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] consensus-yaraft, <a href="https://github.com/neverchanje/consensus-yaraft" target="_blank" rel="noopener">https://github.com/neverchanje/consensus-yaraft</a><br>[2] pegasus, git.n.xiaomi.com/pegasus/pegasus<br>[3] yaraft, <a href="https://github.com/neverchanje/yaraft" target="_blank" rel="noopener">https://github.com/neverchanje/yaraft</a><br>[4] etcd/raft，<a href="https://github.com/coreos/etcd/tree/master/raft" target="_blank" rel="noopener">https://github.com/coreos/etcd/tree/master/raft</a><br>[5] baidu/sofa-pbrpc, <a href="https://github.com/baidu/sofa-pbrpc" target="_blank" rel="noopener">https://github.com/baidu/sofa-pbrpc</a><br>[6] Ongaro, Diego, and John K. Ousterhout. “In search of an understandable consensus algorithm.” USENIX Annual Technical Conference. 2014.<br>[7] kudu/consensus, <a href="https://github.com/cloudera/kudu/tree/master/src/kudu/consensus" target="_blank" rel="noopener">https://github.com/cloudera/kudu/tree/master/src/kudu/consensus</a><br>[8] cameron314/concurrentqueue, <a href="https://github.com/cameron314/concurrentqueue" target="_blank" rel="noopener">https://github.com/cameron314/concurrentqueue</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/14/fuck_u_seu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="neverchanje">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="neverchanje">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/14/fuck_u_seu/" itemprop="url">Fuck You，东南大学</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-14T00:00:00+08:00">
                2017-06-14
              </time>
            

            

            
          </span>

          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原本想写篇长的劝退文告诉后来人这破校有多挫，但是发现这事除了贬低了自己以外没个什么用。<br>从渣校出来以后神清气爽，自带智力光环，回头看学校里一群傻逼，宿舍乱成狗窝，老师只会添乱。既然再也不混这日子了，话也就再不说了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/05/sofa_pbrpc_timeout_manager/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="neverchanje">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="neverchanje">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/05/sofa_pbrpc_timeout_manager/" itemprop="url">baidu sofa-pbrpc 源码阅读：TimeoutManager</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-05T00:00:00+08:00">
                2017-02-05
              </time>
            

            

            
          </span>

          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><p>TimeoutManager 的设计思路是这样的：我们需要注册 event 到 TimeoutManager，每个 event 都有一个 timeout，一旦时间超过 timeout，事件就会发生。<br>每个事件其实就是一个 callback，事件发生时，执行 callback。</p>
<p>具体实现也很简单：一个后台线程（TimerWorker）负责 tick，每 10ms tick 一次，每次 tick 都遍历所有的 timer events，检查哪些 events 超期，如果超期就执行 callback。</p>
<p>这种设计从上层看起来就好像事件都一个个精准地按时发生了，其实不然，每个事件发生的时间都不是严格的 now() + timeout，而是根据 tick 的时间粒度，会有一定的误差。不过这通常是无所谓的。</p>
<p>其实这种设计已经非常经典了。redis ae，以前看到 libevent 也是这么实现（不确定）。TimeoutManager 是一个通用型的设计，如果用户只做 RPC，那这个类对于用户是隐藏的，但用户可以把它作为工具类使用，实用性很强。</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>一个可以讨论的点是 events 要用什么方式存储。</p>
<p>我们可以用 std::vector，在检查哪些 events 超期的时候，理论开销 O(n)。不过因为 timer events 一般不多，所以实际性能可以很快。这是 redis ae 的做法。也可以用 std::set，用一个二分查询找到超期的 events。sofa-pbrpc 用的就是 set。不过 set 如果按 expiration time 排序，那么可能有多个事件的 expiration time 相同。所以可以用 std::multiset。但是我们还要避免事件被重复插入，所以需要一个 unique id 来判断事件是否已经在 set 里头了，如果某事件已经在 set 里，则插入失败。所以现在需求定下来：我们需要一个既能保证 id 唯一，又能按照 expiration time 排序的数据结构。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;Id&gt; id_set_;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;Time&gt; expiration_time_set_;</span><br></pre></td></tr></table></figure>
<p>我们可以像上面那样。当然现在有更好的方法了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> boost::multi_index_container&lt;</span><br><span class="line">    Event,</span><br><span class="line">    boost::multi_index::indexed_by&lt;</span><br><span class="line">        boost::multi_index::ordered_unique&lt;boost::multi_index::member&lt;</span><br><span class="line">        Event, Id, &amp;Event::id</span><br><span class="line">        &gt; &gt;,</span><br><span class="line">    boost::multi_index::ordered_non_unique&lt;boost::multi_index::member&lt;</span><br><span class="line">        Event, int64, &amp;Event::expiration</span><br><span class="line">        &gt; &gt;</span><br><span class="line">    &gt;</span><br><span class="line">&gt; Set;</span><br></pre></td></tr></table></figure>
<h2 id="Use-Case"><a href="#Use-Case" class="headerlink" title="Use Case"></a>Use Case</h2><p>RpcServer 使用 TimeoutManager 作为后台定时事件发生器，实现几个功能：</p>
<h2 id="Keep-Alive"><a href="#Keep-Alive" class="headerlink" title="Keep Alive"></a>Keep Alive</h2><p>显然 KeepAlive 是需要定时器的，一条 stream 如果超过时间没有读写，就应该清理掉。</p>
<h2 id="Flow-Control"><a href="#Flow-Control" class="headerlink" title="Flow Control"></a>Flow Control</h2><p>我以前没有设计过，更没有实现过 flow control，所以对这方面经验很薄弱。</p>
<p>sofa-pbrpc 按照时间片分配流量，用户指定每秒允许的总流量 x MB/s，sofa 会固定每 100ms 的流量是 x/10 MB/s。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Network throughput limit.</span></span><br><span class="line"><span class="comment">// The network bandwidth is shared by all connections:</span></span><br><span class="line"><span class="comment">// * busy connections get more bandwidth.</span></span><br><span class="line"><span class="comment">// * the total bandwidth of all connections will not exceed the limit.</span></span><br><span class="line"><span class="keyword">int</span> max_throughput_in;       <span class="comment">// max network in throughput for all connections.</span></span><br><span class="line">                             <span class="comment">// in MB/s, should &gt;= -1, -1 means no limit, default -1.</span></span><br><span class="line"><span class="keyword">int</span> max_throughput_out;      <span class="comment">// max network out throughput for all connections.</span></span><br><span class="line">                             <span class="comment">// in MB/s, should &gt;= -1, -1 means no limit, default -1.</span></span><br></pre></td></tr></table></figure>
<h2 id="RPC-Timeout"><a href="#RPC-Timeout" class="headerlink" title="RPC Timeout"></a>RPC Timeout</h2><p>@qinzuoyan（sofa 作者） 告诉我，<strong>为什么我们需要删除那些已经加到 TimeoutManager 的事件（TimeoutManager::erase），为什么每个 Event 需要一个 Id</strong>。按道理定时事件加入 TimeoutManager 之后就应该放手不管，就好像我们不应该删除已创建的线程一样。</p>
<p>真实的场景是这样的：RPC 调用需要有 timeout，如果 RPC 超时，则进行错误处理。所以在 client 发起一个 RPC 时，我们注册一个定时任务到 TimeoutManager，如果超时，则进行错误处理。但大部分时候都不会超时，多数情况 RPC 都会成功，我们在成功之后，需要把定时事件从 TimeoutManager 中移除。否则假设每秒 10w 的请求量，定时算在 20s，那 TimeoutManager 会堆积百万量级的定时事件。</p>
<p>上面我们说到 EventId 用来避免事件重复插入，其实这是一个伪需求。真正的原因是我们要拿 EventId ，才能删掉一些无用的定时事件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/30/etcd_raft_core/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="neverchanje">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="neverchanje">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/30/etcd_raft_core/" itemprop="url">Etcd Raft Libary 源码阅读：Core</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-30T00:00:00+08:00">
                2017-01-30
              </time>
            

            

            
          </span>

          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><p>Raft 的基本算法（我们简称 Basic Raft）其实大家都很清楚，已有的博文不要太多，不过老生常谈的知识点大部分集中在 log replication 和 leader election。所以我在这里点一下 consensus: bridging theory and practice（后面我们称 raft thesis） 对 In Search of an Understandable Consensus Algorithm（后面我们称 raft paper）的扩展，还有一些比较少谈到但是对工程实践非常重要的东西。</p>
<h2 id="Leadership-transfer-raft-thesis-3-10"><a href="#Leadership-transfer-raft-thesis-3-10" class="headerlink" title="Leadership transfer (raft thesis 3.10)"></a>Leadership transfer (raft thesis 3.10)</h2><p>具体场景就不说了，简单说，我们要把现在的 leader 换下来，换一个新的 leader 上去。其实这是一个蛮开放的问题，我们可以先放一个 follower 加入集群，然后把 leader 关掉。这样在 electionTimeout 之后集群会进行选举。按照 raft thesis 的说法，这会造成 electionTimeout 期间服务不可用。假如我们有频繁的 leadership transfer 的需求，那这确实是一个问题。</p>
<p>我想到一个方案是，先写一个日志下去把 electionTimeout 改小一点（比如 10s 改为 1s），然后在 leadership transfer 成功之后，把 electionTimeout 改回来。这种方案应该是不可行的，electionTimeout 不应该支持在线更改。</p>
<p>另一方面，我们可能需要指定（钦点）一个 follower 作为新 leader，而走 leader election 流程选出来的 leader 本质上是随机的。</p>
<p>raft thesis 提供的方案是，首先暂停接受 client request，然后让一个（应该是指定的） follower 的日志与 leader 完全同步，随后立刻让 follower 发起 election，由于 term 更大，旧 leader 自然被换下来。这种方案的漏洞是要保证 leader transfer 时，除了我们指定的 follower，没有其他 follower 可以发起选举。这点可以用 prevote 避免，所以 leader transfer 理论上是可以全自动化的（不需要 sysadmin 参与）。并且这种方案的前提是 follower 与 leader 完全同步的平均时间远小于 electionTimeout，当然多数情况是这样的。</p>
<h2 id="Finding-the-cluster-raft-thesis-6-1"><a href="#Finding-the-cluster-raft-thesis-6-1" class="headerlink" title="Finding the cluster (raft thesis 6.1)"></a>Finding the cluster (raft thesis 6.1)</h2><p>这部分其实在 raft paper 里讲的很清楚了，client 发送请求给 cluster 中任意一台 server，如果这台 server 不是 leader，它就返回 leader 的地址。但是我们如何知道 cluster 里有哪些 servers，它们的 ip 是多少？raft thesis 这里提到，可以用 DNS 的方案。</p>
<h2 id="Routing-requests-to-the-leader-raft-thesis-6-2"><a href="#Routing-requests-to-the-leader-raft-thesis-6-2" class="headerlink" title="Routing requests to the leader (raft thesis 6.2)"></a>Routing requests to the leader (raft thesis 6.2)</h2><p>我们在 Etcd 源码阅读：Discovery 提到过关于 zk leader 出现网络分区时，新 leader 选举出来，client 仍然连接旧 leader 的问题。raft 这里给出了解决方案。</p>
<h2 id="Linearizable-semantics-raft-thesis-6-3"><a href="#Linearizable-semantics-raft-thesis-6-3" class="headerlink" title="Linearizable semantics (raft thesis 6.3)"></a>Linearizable semantics (raft thesis 6.3)</h2><p>Basic Raft 没有 session 的概念。为什么 Raft 需要 session？</p>
<p><img src="http://og0xhkmh3.bkt.clouddn.com/raft/raft_session.PNG" alt="client-session"></p>
<p>Raft 协议下的 client-server 模型是有状态的，因此每一个写请求都不是幂等的，写操作1 和 写操作2 可能数据一样，但是它们会被 raft 当成是两个不同的写操作，它们的 index 不同。所以我们需要引入 session，我们只有在 session 内才能做去重。</p>
<p>Further Reading：<a href="http://www.bailis.org/blog/linearizability-versus-serializability/" target="_blank" rel="noopener">Linearizability versus Serializability</a></p>
<h2 id="Read-only-query-raft-paper-8-raft-thesis-6-4"><a href="#Read-only-query-raft-paper-8-raft-thesis-6-4" class="headerlink" title="Read-only query (raft paper 8, raft thesis 6.4)"></a>Read-only query (raft paper 8, raft thesis 6.4)</h2><p>我们知道一个写请求经过 raft 会走一遍 log replication 流程： 写磁盘，分发，过半提交后写成功。但是读请求按道理不需要走日志（就好像 MySQL 读请求不会写 binlog），所以我们需要有专门一个流程。</p>
<p>client 发起读操作的时候，希望能够读到最新记录。所谓最新的意思是，在读请求发起时最后一个 committed 的记录。leader 收到读请求，发起一次 heartbeat，这里证明自己确实是 leader，根据 leader completeness 属性，leader 拥有最新记录，我们这就能回复 client 了。</p>
<p>这种方案可以省掉一次磁盘写开销，但是日志分发还是不可避免（heartbeat）。所以我们可以批处理连续的读请求。</p>
<h2 id="Prevote-raft-thesis-9-6"><a href="#Prevote-raft-thesis-9-6" class="headerlink" title="Prevote (raft thesis 9.6)"></a>Prevote (raft thesis 9.6)</h2><p>在 Basic Raft 里，follower 在 electionTimeout 没收到心跳之后会发起投票，转为 candidate。然而 follower 超过 electionTimeout 没有收到心跳，很可能是由于自己的网络问题。这时候即使它发起投票，别人也不会给它响应，等它网络恢复，成功收到 leader 的心跳，它却还是会发起投票，强制集群进行一次 leader election，即使此时集群压根不需要选举新 leader。所以我们可以使用 prevote 算法。我们可以先询问其他节点，是否愿意参与选举，如果节点能够正常感知 leader，它就不会参与选举，如果节点同样认为 leader 挂了，则参与选举。过半节点参与，我们才可以发起 leader election。</p>
<p>Further Reading：<a href="http://blog.neverchanje.com/2017/01/31/morning_paper_four_modifications_mongo_raft/" target="_blank" rel="noopener">MongoDB: Four modifications for the Raft consensus algorithm</a></p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>etcd 对 raft 的实现算是比较完整了，我不知道是不是上面的每一个功能点都会被 etcd 用到。所以我个人也是倾向于把 raft 拉出来单独作为一个项目。</p>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>这是 Raft 的入口，表示一个 Raft 节点，每个节点接收到一个消息，都会驱动一次状态机转移。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step advances the state machine using the given message. ctx.Err() will be returned, if any.</span></span><br><span class="line">Step(ctx context.Context, msg pb.Message) error</span><br></pre></td></tr></table></figure>
<p>看到这个接口返回 error 的方式可以看出来，我们可以用全异步事件模型操作状态机（context.Context），也可以用简单同步模型操作状态机。</p>
<ul>
<li><p>全异步模型依赖 golang 的 channel 机制，Raft 状态机作为一个 background thread（后面我们简称 Raft Thread，或者 Raft Routine），接收上层传来的消息（通过 channel 传递消息）。状态机接收消息，进行转移。转移后的结果会异步返回给上层（node.go:Ready）。</p>
</li>
<li><p>简单模型就是执行 Step 时，等待状态机转移完，再得到结果，整个过程是串行同步而非并行异步的方式。这种模型的好处就是方便移植（tikv 的 rust raft 就是移植此模型），调试简单，而且实际性能应该也不差。</p>
</li>
</ul>
<p>当然 etcd/raft 本身是异步的状态机。状态机本身异步和上层异步操作状态机是两回事。讲起来很绕，希望读者读到后面能够理解这句话。</p>
<h3 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h3><p>etcd/raft 有一点厉害的就是它把 Raft 状态机完整地作为库来实现，其实我们都明白，这需要很长时间打磨，才能把状态机解耦出来。所以我才推崇，其他语言的 Raft 实现应该把 etcd/raft 的设计翻译过去，而不是自己从头踩坑（开源协议上也是支持这么做的）。</p>
<ul>
<li>发送消息：比如 follower 节点的状态机接收到 AppendEntries，它要发送 response。这时候 follower 会把消息放入 mailbox，一个内存的消息队列，真正的消息发送交给上层执行。</li>
</ul>
<h3 id="CheckQuorum"><a href="#CheckQuorum" class="headerlink" title="CheckQuorum"></a>CheckQuorum</h3><p>Basic Raft 下，leader 只有在收到更大的 term 时才会 step down，所以在发生网络分区时，即使在其他分区里新的 leader 已经被选举出来，而旧 leader 由于接收不到新 leader 的 heartbeat，它依然会认为自己是 leader。</p>
<p>CheckQuorum 机制就是，每隔 electionTimeout，如果 leader 发现少于过半的节点活跃（响应心跳），则主动 step down。</p>
<p>这点是 etcd/raft 自己做的优化。</p>
<h3 id="NextIndex-Decrease"><a href="#NextIndex-Decrease" class="headerlink" title="NextIndex Decrease"></a>NextIndex Decrease</h3><p>我们知道 Raft 里 Log Matching Property 保证日志项中间不会有 holes，即日志项连续。所以 Leader 要为每个 Follower 设置一个 nextIndex（raft paper 5.3），表示下一个要发送的日志 index，如果 nextIndex 太大（此时 follower 会返回 rejection，具体地说，follower 会在 index 大于 committedIndex 时返回 rejection），就把 nextIndex 调小一点。</p>
<p>调小的策略对性能有一定的影响（不过一般情况是不会有 rejection 的，所以只会影响少数情况下的性能）。</p>
<ul>
<li>简单的方法可以是 nextIndex-=1，然后 retry。慢慢降下来总能对上。raft paper 其实推荐这种做法，读者可以在 raft.tla 看到这个逻辑。</li>
<li>我们知道 etcd/raft 的状态机是异步模型，发送 AppendEntries 的一方并不会等待 AppenedEntriesResp 发送回来，而是继续处理其他的消息。所以可能当我们收到 AppendEntriesResp 的时候，nextIndex-1 已经不是 rejectedIndex 了。这时候去处理这个 rejection 是没意义的，nextIndex 不需要改变。</li>
<li>有一种情况是，虽然 follower 发出 rejection 的时候，它还没有 nextIndex-1 报文，但在 leader 收到 rejection 的时候，follower 提交了 nextIndex-1 报文。这时候我们不需要尝试其他更小的值，再发一次 nextIndex，follower 一定能接受。什么时候会发生这种情况：<code>rejectedIndex &lt;= matchIndex</code> 时。raft leader 维护 matchIndex，表示成功 committed 到状态机的最大 index。</li>
<li>对于 <code>rejectedIndex &gt; matchIndex</code> 的情况，我们必须要将 nextIndex 调小，所谓调小，就是让 <code>nextIndex &lt; rejectedIndex</code>。所以我们需要让 nextIndex 的值保证：<code>matchIndex &lt; nextIndex &lt; rejectedIndex</code>。一种方案是 nextIndex = matchIndex + 1。</li>
<li>raft paper 5.3 提到，rejection 可以附加一些信息，用来提示 leader 如何调整 nextIndex。最早我想应该附加 committedIndex，表示 follower 持久化到磁盘的最大 index，后来发现其实没必要，只需要发回 follower 接收到的最大 index 即可，不用管是否持久化。如果考虑持久化，那 nextIndex 会太小。</li>
</ul>
<p>可以看出 etcd/raft 确实在 nextIndex decrease 策略上下了点功夫，虽然我个人更支持简单的 nextIndex-=1 的方案。Log Matching Property 保证了，nextIndex-=1 永远是对的。不过 etcd/raft 的确能够在一些场景下，省去几次 RTT 开销。</p>
<p>另外提醒一点，如果 leader 发送的 nextIndex 在 follower 上已经有了（<code>index &lt; committedIndex</code>），follower 不会返回 rejection，而是会告诉 leader 它的 committedIndex，leader 就会跟进 nextIndex。</p>
<h2 id="Progress"><a href="#Progress" class="headerlink" title="Progress"></a>Progress</h2><p>我一开始也没想到在 Raft 里头还有一个挺复杂的子状态机。</p>
<p>参考 <a href="https://github.com/coreos/etcd/blob/master/raft/design.md" target="_blank" rel="noopener">etcd/raft progress</a> 文档。</p>
<p><img src="http://og0xhkmh3.bkt.clouddn.com/etcd/progress.PNG" alt="etcd/raft progress"></p>
<p>这个设计蛮有道理，不过在 raft paper 里没有描述。正常我们只需要考虑，leader 接收写请求，然后把写操作复制给 follower，如果 follower 落后太多，就发送 snapshot。但是如果写请求非常多，再碰上网络分区时，leader 可能会在 buf 里累积很多待发送消息，一旦网络恢复，可能会有非常大流量顿时发送给 follower。所以一定要做 flow control。</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>[ ] 后续参考 MongoDB 对 Raft 的修改，为 raft 加入新的机制。<br>[ ] 未来可以看 logcabin 和 consul 对 raft 的实现设计。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/28/mysql_utf8_perf_degrade/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="neverchanje">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="neverchanje">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/28/mysql_utf8_perf_degrade/" itemprop="url">MySQL UTF-8 导致性能下降</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-28T00:00:00+08:00">
                2017-01-28
              </time>
            

            

            
          </span>

          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h2><p>有段时间公司云 MySQL 性能降低了很多，我们跟了一下上线记录，发现是 MySQL 的配置在一个月之前有改动（可见每次上线前的改动都要严格地记录下来，并且需要便于查看）。我们回退每个配置项修改，每次回退都做一次性能测试，最终发现是我们把字符集从 latin 改为 utf8，造成的这次性能下降。</p>
<h2 id="问题调研"><a href="#问题调研" class="headerlink" title="问题调研"></a>问题调研</h2><p>MySQL utf-8 会导致字符串体积增加，会对所有内部 buffer 机制造成影响，例如只有更少的索引更够被放入内存等，所以会导致性能下降。</p>
<p>虽然 utf-8 默认是 4 bytes，但是 MySQL 只会用 3 bytes 存储，这是因为大部分字符不需要 4 bytes。所以理论上：</p>
<ul>
<li>同一个 CHAR 声明的字符串用 latin 存储和用 utf-8 存储空间上会差 3 倍</li>
<li>对于 VARCHAR 声明的 utf8 存储，相对会节省空间，如果只需要 1 byte 便可表示的字符，那就不会用 3 bytes（是类似 protobuf 的 varint 机制？）</li>
<li>但是不管是对于 CHAR 和 VARCHAR，在许多任务上还是按照最大可能使用内存来分配的。在存储时，VARCHAR(255) 确实会优于 CHAR(255)，前者理论上会花费更少空间。但是在其他地方（比如排序）时，MySQL 依然会直接分配 255 bytes 的空间给 VARCHAR。所以特别是在使用 utf-8 时，需要更加注意 VARCHAR 的使用。</li>
</ul>
<p>所以将 MySQL 的默认编码改成 utf-8 后造成性能下降应该是正常现象。</p>
<h2 id="额外的调研"><a href="#额外的调研" class="headerlink" title="额外的调研"></a>额外的调研</h2><ul>
<li><p>MySQL 会将字符长度分为 CHAR_LENGTH() 和 LENGTH()，对于 utf8 的字符串，后者是前者的 3 倍。</p>
</li>
<li><p>MySQL 限制索引列不能超过 999 bytes，相当于不能有超过 333 个 utf8 字符。</p>
</li>
<li><p>字符集的意义在于进行字符串比较（e.g. LIKE），排序，字符串操作（e.g. SUBSTRING），而如果完全不需要这些操作，可以直接使用 binary，对于复杂情况，可以多加一列，表示字符集。</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://adayinthelifeof.nl//2010/12/04/about-using-utf-8-fields-in-mysql/" target="_blank" rel="noopener">https://adayinthelifeof.nl//2010/12/04/about-using-utf-8-fields-in-mysql/</a></li>
<li>High Performance MySQL, p298 ch7 — Character Sets and Collations</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="neverchanje" />
            
              <p class="site-author-name" itemprop="name">neverchanje</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/neverchanje" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">neverchanje</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
